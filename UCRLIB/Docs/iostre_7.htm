<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE> </TITLE>
</HEAD>
<BODY>
<A NAME=HEADING1></A>
IOStream Routines<P>
<HR>
<!-- TOC --><DL>
<DT><A HREF="iostre_1.htm#HEADING1-1"><B></B>UCR Standard Library: IOStream Routines</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-3"><B>9.1	</B> - Interface</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-11"><B>9.2	</B> - Overview of the Stream Output  Facilities</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-14"><B>9.3	</B> - COUT</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-24"><B>9.3.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-25"><B>9.3.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-33"><B>9.4	</B> - CIN</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-37"><B>9.4.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-38"><B>9.4.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="iostre_1.htm#HEADING1-55"><B>9.5	</B> - Extending COUT and CIN to Handle Other Data Types</A>
<DD>
</DL>

<A NAME=HEADING1-0></A>
<H1></H1>
<HR>
<A NAME=HEADING1-1></A>
<H1> UCR Standard Library: IOStream Routines</H1>
 The IOStream package provides a simplified I/O system for assembly language programmers.  It somewhat parallels the standard output iostream COUT and CIN facilities found in the C++ programming language.<P>
<A NAME=HEADING1-3></A>
<HR>
<H2>9.1  Interface</H2>
 To access the routines in the declarations  package, your assembly language module must include the file &quot;iostream.a&quot; during assembly.  You can accomplish this with either of the following include statements in your assembly code:<P>
<PRE>
	include	iostream.a
or
	include	ucrlib.a

</PRE>
 The iostream.a include file exports several symbols.  The UCR Standard Library prefaces all &quot;private&quot; names with a dollar sign (&quot;$&quot;).  You should not call any routine in this package that begins with this symbol unless otherwise advised.  To avoid name conflicts, you should not define any symbols in your programs that begin with a dollar sign (&quot;$&quot;).  Note that future versions of the stdlib (that remain compatible with this release)  may change &quot;private&quot; names.  To remain compatible with future releases, you must not refer to these &quot;private&quot; names within your programs.<P>
 Source code appearing in this chapter is current as of Version Two, Release 40.   There may be minor changes between this source code and the current release.<P>
<A NAME=HEADING1-11></A>
<HR>
<H2>9.2  Overview of the Stream Output  Facilities</H2>
 The IOStream package provides a macro that simulates the COUT stream output and CIN stream input operators in C++.  These macro, in conjunction with the DCL.A package, automatically figure out the type of their  operands and print or read them in an appropriate fashion.  These macros greatly simplify  reading and writing data through the standard input/output devices, especially for beginners and for &quot;quick and dirty&quot; programming.<P>
 For slightly better control of the output data, you should also take a look at printf and printff in the standard output package.<P>
<A NAME=HEADING1-14></A>
<HR>
<H2>9.3  COUT</H2>
 The COUT macro requires one or more operands.  It attempts to decipher the type of the operands and print them using an appropriate format.    A typical COUT invocation takes the form:<P>
<PRE>
	cout	operand1, operand2, ...

</PRE>
 If an operand is an identifier declared within the VAR..ENDVAR using a standard type definition macro (e.g., integer), then COUT will print the value of that variable using its native format.  The following lists the possible output formats:<P>
 If the COUT operand is an 80x86 register, COUT can't really determine the data type of the corresponding value, so it prints the value of the register using hexadecimal notation (two digits for eight bit registers, four digits for 16-bit registers, and eight digits for 32-bit registers). <P>
 If the COUT operand is a constant, COUT will print that constant as an ASCII character.  Similarly, if the COUT operand is a string, COUT will print that string literal to the standard output device.<P>
 If the COUT operand is a byte, sbyte, word, sword, dword, or sdword variable, COUT will print type(xxxx) where type is the type name (byte, sbyte, word, etc) and xxxx is the hexadecimal representation of that value.  Since programmers can store many different types into these types of variables, COUT does not try to interpret the results.<P>
 If you supply any other operand type to COUT, MASM will generate an error.<P>
 If you create your own types using the DCLTYPE macro, you can provide a macro that will allow COUT to print your data type.  For more details, see the DCLTYPE macro in the chapter  on declarations (DCLS) and the section on extending CIN and COUT later in this chapter.<P>
<A NAME=HEADING1-24></A>
<HR>
<H2>9.3.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-25></A>
<HR>
<H2>9.3.2  Syntax &amp; Examples</H2>
<PRE>
	cout &quot;Hello world&quot;,13,10

</PRE>
 The following is a more typical use of the COUT statement:<P>
<PRE>
	cout &quot;I=&quot;,i, &quot; F=&quot;,F, &quot; string='&quot;,string,&quot;'&quot;,nl

	I=10 F= 1.500000e+00 'Hello There'

</PRE>
<A NAME=HEADING1-33></A>
<HR>
<H2>9.4  CIN</H2>
 CIN provides an easy way to input values for variables you declare with TYPEDCL type macros.  Unlike COUT, CIN only allows variable names as operands and you must declare these variables using type declaration macros in the VAR..ENDVAR section.  CIN will not input values into registers, variables declared with MASM directives, or other objects.<P>
 CIN supports the input of all stdlib predefined variable types.  It calls the following standard input routines for each of these types:<P>
 You can extend CIN so that it can read values of types that you define.  See the appropriate section later in this chapter.<P>
<A NAME=HEADING1-37></A>
<HR>
<H2>9.4.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-38></A>
<HR>
<H2>9.4.2  Syntax &amp; Examples</H2>
<PRE>
var
        integer intval
        float fpval
        string str[128]
endvar

                 .
                 .
                 .
                cout    &quot;Enter an integer and a floating point value:&quot;
                cin     intval, fpval
                cout    &quot;Enter a line of text:&quot;
                cin     str
                 .
                 .
                 .
</PRE>
<A NAME=HEADING1-55></A>
<HR>
<H2>9.5  Extending COUT and CIN to Handle Other Data Types</H2>
 The DCLS.A and IOSTREAM.A packages work together to simplify I/O programming in assembly language.  In particular, the types you create with the DCLTYPE macro (including the stdlib's predefined types) communicate type information to CIN and COUT so these routines can call the appropriate stdout or stdin routines to print or input the associated variable.<P>
 Consider the following type declaration:<P>
<PRE>
	dcltype	LHex, dword			;A 32-bit hexadecimal value

	LHex	LHvar1
	LHex	LHVar2=0FFFF0000h
	LHex	LHvar3[20], LHVar4[10]=0FFFFh
	LHex	*LHvar5, *LHvar6=LHVar5, *LHVar7[4], *LHVar8[4]=LHVar5

</PRE>
 Whenever you declare a variable using one of these type macros, the macro emits the appropriate MASM statements to allocate storage for the variable.  For simple variables (like LHvar1 above), the type macro emits the directive specified by the second operand to the DCLTYPE macro (dword in this case):<P>
<PRE>
	LHvar1	dword	?

</PRE>
 When you specify an initial value (as for LHVar2, above), the LHex macro substitutes the initial value for the &quot;?&quot; in the operand field of the MASM directive, e.g.,<P>
<PRE>
	LHVar2	dword	0FFFF0000h

</PRE>
 When you declare an array by adding a subscript to the name, the LHex macro generates an appropriate &quot;dup&quot; operator in the operand field of the dword directive:<P>
<PRE>
	LHVar3	dword	20 dup (?)
	LHVar4	dword	10 dup (0FFFFh)

</PRE>
 If you place an asterisk in front of the variable name, the type macro will use the &quot;dword&quot; directive to reserve four bytes of storage for a far pointer (this isn't obvious in this case since the LHex macro emits a dword directive anyway).  If you specify an array or an initial value, the type directive emits the appropriate dword operand:<P>
<PRE>
	LHvar5	dword	?
	LHVar6	dword	LHVar5
	LHVar7	dword	4 dup (?)
LHVar8	dword	4 dup (LHVar5)

</PRE>
 Consider one more example that clearly demonstrates what is happening when you declare a pointer variable:<P>
<PRE>
	dcltype	SInt, sbyte			;Short integer: -128..+127
	SInt	si, *sip

	si	sbyte	?
	sip	dword	?

</PRE>
 Note that from a C++ point of view the standard library probably should have used the &quot;&amp;&quot; symbol rather then &quot;*&quot; to denote a reference (pointer) variable since the CIN and COUT routines automatically dereference pointer variables.  However, the &quot;&amp;&quot; symbol is an operator in MASM and it was easier to use the &quot;*&quot; symbol.<P>
 In addition to emiting the directives that allocate space for a variable you declare, the type declaration macros also emit a text equate for each symbol you define.  The text equate always takes the following form:<P>
<PRE>
	$?varname	textequ	&lt;typename&gt;

	LHex	H1, *H2=H1

	H1	dword	?
	$?H1	textequ	&lt;LHex&gt;
	H2	dword	H1
	$?H2	textequ	&lt;*LHex&gt;

</PRE>
 If a variable appears in the operand field of the COUT statement, the COUT macro first checks to see if it is a type macro declared variable using the technique described above.  If this is the case, then COUT will invoke one of two macros to print the variable's value:<P>
<PRE>
	$$PV_typename  varname
or	$$PP_typename  varname

	cout	H1, H2

	$$PV_LHex H1
	$$PP_LHex H2

</PRE>
 Although the type declaration macro can create the &quot;$?varname&quot; symbol for you, it is not smart enough to write the $$PP_typename and $$PV_typename  macros for you.  You must write these macros and they must take the following form:<P>
<PRE>
$$PV_typename   macro   varname

        &lt;code that prints varname's value&gt;

                endm
                
$$PP_typename   macro   varnamePtr

        &lt;code that fetches the data at
         address &quot;varnamePtr&quot; and prints it&gt;

                endm

</PRE>
 COUT automatically preserves the values in the EAX, ES, and DI registers.  Therefore, you may use these registers within your macros without saving their contents.  If you use any other registers, you must preserve their values within the macro if you expect COUT to preserve their values.  Consider the LHex data type defined earlier:<P>
<PRE>
$$PV_LHex       macro   Hex32
                mov     ax, word ptr Hex32+2
                putw
                mov     ax, word ptr Hex32
                putw
                endm
                
$$PP_LHex       macro   Hex32Ptr
                les     di, dword ptr Hex32Ptr
                mov     ax, es:[di+2]
                putw
                mov     ax, es:[di]
                putw
                endm


</PRE>
 CIN interfaces with the DCLTYPE macro in a similar manner except you define $GP_typename and $GV_typename  macros that read the data from the standard input.  The following macros supply the input side of the LHex data type:<P>
<PRE>
$$GV_LHex       macro   Hex32toRead
                getlh
                mov     Hex32ToRead, eax
                endm
                
$$GP_LHex       macro   Hex32Ptr2Rd
                getlh
                les     di, Hex32Ptr2Rd
                mov     es:[di], eax
                endm

</PRE>
 Once you define the macros above, CIN and COUT will work properly with the new data type you've created.  In addition to the above macros, you should also define a symbol $$typename  whose value is the number of bytes required by the object, e.g.,<P>
<PRE>
$$LHex	=	4
</PRE>
 <P>
 You can also use the stdlib ENUM statement (see the chapter on declarations) to declare new data types of which COUT and CIN are aware.  Consider a statement like the following:<P>
<PRE>
	enum	colors, &lt;red, green, blue&gt;
	typedcl	colors, byte

</PRE>
 <P>
<PRE>
	enum colors, &lt;red, green, blue$$PV_colors     macro   color
                mov     al, byte ptr color
                call    PrintColors
                endm
                
$$PP_colors     macro   color
                les     di, dword ptr color
                mov     al, es:[di]
                call    PrintColors
                endm
                
PrintColors     proc
                cmp     al, red
                jne     NotRed
                print   &quot;red&quot;
                ret
                
NotRed:         cmp     al, green
                jne     NotGreen
                print   &quot;green&quot;
                ret
                
NotGreen:       cmp     al, blue
                jne     NotBlue
                print   &quot;blue&quot;
                ret
                
NotBlue:        print   &quot;Illegal Color!&quot;
                ret
PrintColors     endp



$GV_Colors      macro   Color2Read
                call    GetColor
                mov     byte ptr Color2Read, al
                endm
                
$GP_Colors      macro   ColorPtr
                call    GetColor
                les     di, ColorPtr
                mov     es:[di], al
                endm
                


TstChar         macro   Chars
                forc    chr, &lt;Chars&gt;
                getc
                tolower
                cmp     al, '&amp;chr&amp;'
                jne     BadColor
                endm
                endm
                
                
GetColor        proc    near
                getc
                jc      BadColor        ;If GETC error.
                tolower                 ;Allow upper and lower case.
                cmp     al, &quot;r&quot;
                je      MustBeRed
                cmp     al, &quot;g&quot;
                je      MustBeGreen
                cmp     al, &quot;b&quot;
                je      MustBeBlue
                
; Illegal character.  Cannot be red, green, or blue at this
; point.  So if exceptions are enabled, raise an exception.

BadColor:       GetXEnabled
                cmp     ax, 0
                je      NoExceptions
                mov     ax, $Conversion
                Raise

; If exceptions are not enabled, just return with a bogus value.

                mov     ax, -1
                stc
                ret

MustBeRed:      tstchar ed
                mov     al, red
                ret
                
MustBeGreen:    tstchar reen
                mov     al, green
                ret
                
                
MustBeBlue:     tstchar lue
                mov     al, blue
                ret
GetColor        endp


</PRE>
</BODY>
</HTML> 