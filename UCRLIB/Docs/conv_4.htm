<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE> </TITLE>
</HEAD>
<BODY>
<A NAME=HEADING1></A>
Standard Library -- Conversions<P>
<HR>
<!-- TOC --><DL>
<DT><A HREF="conv_1.htm#HEADING1-1"><B></B>UCR StdLib v2.0: Conversion Routines</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-3"><B>6.1	</B> - Interface</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-12"><B>6.2	</B> - Generic Interface</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-39"><B>6.3	</B> - Atof, AtofCS, Atofx, AtofStk</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-53"><B>6.3.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-86"><B>6.3.2	</B> - Atof Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-88"><B>6.3.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-112"><B>6.4	</B> - Atoh, AtohCS, Atohx, AtohStk, AtohTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-120"><B>6.4.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-160"><B>6.4.2	</B> - Atoh Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-168"><B>6.4.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-226"><B>6.5	</B> - Atoi, AtoiCS, AtoiStk, AtoiTOS, AtoiX</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-237"><B>6.5.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-277"><B>6.5.2	</B> - Atoi Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-285"><B>6.5.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-348"><B>6.6	</B> - AtoL, AtoLCS, AtoLx, AtoLStk, AtoLTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-350"><B>6.6.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-390"><B>6.6.2	</B> - AtoL Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-398"><B>6.6.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-456"><B>6.7	</B> - Atolh, Atolhx, AtolhStk, AtolhTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-464"><B>6.7.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-504"><B>6.7.2	</B> - Atolh Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-512"><B>6.7.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-570"><B>6.8	</B> - Atou, AtouCS, AtouTOS, AtouStk, Atoux</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-574"><B>6.8.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-614"><B>6.8.2	</B> - Atou Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-622"><B>6.8.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-679"><B>6.9	</B> - Atoul, AtoulCS, Atoulx, AtoulStk, AtoulTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-681"><B>6.9.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-721"><B>6.9.2	</B> - Atoul Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-729"><B>6.9.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-787"><B>6.10	</B> - etoa, etoax, etoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-789"><B>6.10.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-811"><B>6.10.2	</B> - Etoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-815"><B>6.10.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-851"><B>6.11	</B> - ftoa, ftoax, ftoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-853"><B>6.11.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-875"><B>6.11.2	</B> - Ftoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-879"><B>6.11.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-919"><B>6.12	</B> - Htoa, HtoaCS, HtoaStk, HtoaTOS, Htoax, Htoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-921"><B>6.12.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-964"><B>6.12.2	</B> - Htoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-973"><B>6.12.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1037"><B>6.13	</B> - ISize, ISizeCS, ISizeStk, ISizeTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1039"><B>6.13.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1064"><B>6.13.2	</B> - ISize Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1070"><B>6.13.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1139"><B>6.14	</B> - Itoa, ItoaCS, ItoaStk, ItoaTOS, Itoax, Itoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1141"><B>6.14.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1184"><B>6.14.2	</B> - Itoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1193"><B>6.14.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1277"><B>6.15	</B> - LSize, LSizeCS, LSizeStk, LSizeTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1279"><B>6.15.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1304"><B>6.15.2	</B> - LSize Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1310"><B>6.15.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1378"><B>6.16	</B> - Ltoa, LtoaCS, LtoaStk, LtoaTOS, Ltoax, Ltoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1380"><B>6.16.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1423"><B>6.16.2	</B> - Ltoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1432"><B>6.16.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1516"><B>6.17	</B> - toFlt, toFltStk,toFltCS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1523"><B>6.17.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1544"><B>6.17.2	</B> - ToFlt Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1548"><B>6.17.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1588"><B>6.18	</B> - toHex, toHexStk, toHexTOS, toHexCS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1595"><B>6.18.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1624"><B>6.18.2	</B> - ToHex Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1632"><B>6.18.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1699"><B>6.19	</B> - toInt, toIntStk, toIntCS, toIntTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1706"><B>6.19.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1735"><B>6.19.2	</B> - ToInt Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1743"><B>6.19.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1810"><B>6.20	</B> - toLHex, toLHexStk, toLHexTOS, toLHexCS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1812"><B>6.20.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1840"><B>6.20.2	</B> - ToLHex Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1848"><B>6.20.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1915"><B>6.21	</B> - toLong, toLongStk, toLongTOS, toLongCS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1922"><B>6.21.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1951"><B>6.21.2	</B> - ToLong Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-1959"><B>6.21.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2026"><B>6.22	</B> - toULong, toULongStk</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2033"><B>6.22.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2061"><B>6.22.2	</B> - ToULong Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2069"><B>6.22.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2136"><B>6.23	</B> - toUns, toUnsStk, toUnsTOS, toUnsCS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2143"><B>6.23.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2172"><B>6.23.2	</B> - ToUns Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2180"><B>6.23.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2247"><B>6.24	</B> - UlSize, UlSizeCS, UlSizeStk, UlSizeTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2249"><B>6.24.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2274"><B>6.24.2	</B> - UlSize Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2280"><B>6.24.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2348"><B>6.25	</B> - Ultoa, UltoaCS, UltoaStk, UltoaTOS, Ultoax, Ultoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2350"><B>6.25.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2393"><B>6.25.2	</B> - Ultoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2402"><B>6.25.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2486"><B>6.26	</B> - USize, USizeCS, USizeStk, USizeTOS</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2488"><B>6.26.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2513"><B>6.26.2	</B> - USize Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2519"><B>6.26.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2588"><B>6.27	</B> - Utoa, UtoaCS, UtoaStk, UtoaTOS, Utoax, Utoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2590"><B>6.27.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2633"><B>6.27.2	</B> - Utoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2642"><B>6.27.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2726"><B>6.28	</B> - Wtoa, WtoaCS, WtoaStk, WtoaTOS, Wtoax, Wtoam</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2728"><B>6.28.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2771"><B>6.28.2	</B> - Wtoa Addressing Modes</A>
<DD>
<DT><A HREF="conv_1.htm#HEADING1-2780"><B>6.28.3	</B> - Syntax &amp; Examples</A>
<DD>
</DL>

<A NAME=HEADING1-0></A>
<H1></H1>
<HR>
<A NAME=HEADING1-1></A>
<H1> UCR StdLib v2.0: Conversion Routines</H1>
 The UCR Standard Library (stdlib) contains a large number of routines that convert data from one format to another.   These routines typically convert between some binary format and ASCII.  For example, the ATOI routine converts an ASCII string to an integer.  Conversely, the Utoa routine converts an integer value to an ASCII string.  There are other conversions as well.  For example, the TOUPPER routine converts lower case characters to upper case.<P>
<A NAME=HEADING1-3></A>
<HR>
<H1>6.1  Interface</H1>
 To access the routines in the conversions package, your assembly language module must include the file &quot;conv.a&quot; during assembly.  You can accomplish this with either of the following include statements in your assembly code:<P>
<PRE>
	include	conv.a
or
	include	ucrlib.a

</PRE>
 Note that the &quot;ucrlib.a&quot; include file automatically includes all include files associated with the UCR Standard Library.<P>
 The conv.a include file exports several symbols.  The UCR Standard Library prefaces all &quot;private&quot; names with a dollar sign (&quot;$&quot;).  You should not call any routine in this package that begins with this symbol.  To avoid name conflicts, you should not define any symbols in your programs that begin with a dollar sign (&quot;$&quot;).  Note that future versions of the stdlib (that remain compatible with this release)  may change &quot;private&quot; names.  To remain compatible with future releases, you must not refer to these &quot;private&quot; names within your programs.<P>
 Source code appearing in this chapter is current as of Version Two, Release 40.   There may be minor changes between this source code and the current release.<P>
<A NAME=HEADING1-12></A>
<HR>
<H1>6.2  Generic Interface</H1>
 Many of the standard library routines use a common generic programmer's interface.  Such routines let you pass parameters to them in several different locations.  Common examples include in the registers, by value in the code stream (CSi), by reference in the code stream (CS), by value on the top of stack (TOS), and by reference on the top of stack (Stk).  Typically, there are separate invocation macros defined for each of these variants, e.g.,<P>
<PRE>

        IsAlNum                 ;Passed in AL register.

        IsAlNumCS
        dword   chrPtr          ;Passed by reference in code stream.

        push    'a'             ;Passed by value on the stack.
        IsAlNumTOS

        push    seg chrVar      ;Passed by reference on the stack.
        push    offset chrVar
        IsAlNumStk

</PRE>
 Note that you will rarely find actual routines that pass their parameters by value in the code stream using the &quot;CSi&quot; suffix.  The reason this is so is because most such routines use different, more descriptive names.  For example, &quot;PutsCSi&quot; goes by the name &quot;Print&quot;.<P>
 In addition to the above forms there are two other suffixes generally applied to stdlib routine names: &quot;m&quot; and &quot;x&quot;.  The &quot;m&quot; suffix stands for &quot;malloc&quot;.  Routines with the &quot;m&quot; suffix typically generate a string result and malloc storage for the string on the heap, returning a pointer to this string in the ES:DI register pair.  The routines with an &quot;x&quot; suffix also process strings.  Most stdlib routines preserve the value of the ES:DI registers when processing strings; typically, they leave the ES:DI register pair pointing at the start of the string.  The routines with an &quot;x&quot; suffix do not preserve ES:DI, they generally leave ES:DI pointing at the zero byte of the string they processed or generated.<P>
 To make it easier to use all these different variants, the standard library typically defines a macro for each routine that lets you specify various operands using stdlib &quot;addressing modes.&quot;  The allowable addressing modes vary by routines, but they typically take one of the following forms:<P>
<PRE>

        name            ;If operand field is blank, use &quot;plain&quot; version.
        name    var     ;Generally passes address of var in code stream.
        name    const   ;Pushes const onto TOS and uses nameTOS routine.
        name    [wvar]  ;Pushes DS followed by value of wVar variable
                        ; (assumed to be a word) and calls nameSTK
        name    [dVar]  ;Pushes dword value of dVar and calls nameStk.

</PRE>
 Since not all of these &quot;addressing modes&quot; are applicable to all instructions, and some instructions allow different sets of operands (including multiple operands), there are lots of special cases.  Such cases are noted after the explaination for each particular routine.<P>
<A NAME=HEADING1-39></A>
<HR>
<H1>6.3  Atof, AtofCS, Atofx, AtofStk</H1>
 These routines convert a string of ASCII characters to an 80-bit floating point value.  On entry to Atof and Atofx, the ES:DI register pair contains the address of the string to convert;  on entry to AtofStk, the far address of the string appears on the stack; for AtofCS, the address follows the call in the code stream.  On return from these routines, the ST(0) register (top of FPU stack) contains the real value assuming there was no conversion error.  If a conversion error occurs, these routines return the carry flag set.  If no such error occurs, these routines return the carry flag clear.<P>
 These routines flag an error under under the following conditions: <P>
 The string (after removing leading spaces) doesn't begin with one of the following, where &quot;d &quot; represents a single decimal digit:<P>
 <P>
<PRE>
-d     -.d     +d     +.d     d     .d
</PRE>
 <P>
 An error will also occur if there are two (or more) decimal points in a floating point number or if the exponent (if present) doesn't contain at least one decimal digit after the &quot;E&quot;, &quot;e&quot;, or exponent sign character.  Finally, ATOF also returns an error condition if the exponent is outside the rang e -4930..+4930.<P>
 A typical floating point value takes the form   sign  digits  .  digits   E sign digits.  The sign can be a plus or minus sign.  Digits represents a string of zero or more digits.  A syntactically correct floating point value has a sequence of one or more digits either before or after the decimal point.  All other fields are optional.  Note that Atof will properly convert a simple string of  digits (i.e., integer representation) to a floating point value.  No exponent or decimal point is required.  The following regular expression describes legal input to Atof:<P>
<PRE>

[+ | -]?  [&quot;0&quot;..&quot;9&quot;]+   [ &quot;.&quot;  [&quot;0&quot;..&quot;9&quot;]*]?  [ [&quot;E&quot; | &quot;e&quot;] [+|-]? [&quot;0&quot;..&quot;9&quot;]+]?

</PRE>
 Unlike integer strings, Atof does not allow underscores in floating point numbers.<P>
 If you need to verify that the conversion did not end on an illegal symbol, you should use the Atofx routine.  This routine leaves ES:DI pointing at the first character it was not able to convert (assuming Atofx returns with the carry flag clear).  You can compare the character ES:DI points at against a set of legal characters that you want to allow as number termination characters.<P>
<A NAME=HEADING1-53></A>
<HR>
<H2>6.3.1  Calling Conventions and Assertions</H2>
<PRE>
Atof:
Inputs:	ES:DI points at the string to convert.
Outputs:	ST(0) contains the signed result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some real number.
Note:	Atof will skip leading spaces in the string before the conversion begins.

Atofx:
Inputs:	ES:DI points at the string to convert.
Outputs:	ST(0) contains the real result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Does not preserve DI.  Assuming C=0 upon return, DI will point at the character it could not convert.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some real number.
Note:	Atofx will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
AtofCS:
Inputs:	A far pointer to the string to convert follows the call in the code stream.
Outputs:	ST(0) contains the real result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some real number.
Note:	AtofStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
AtofStk:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	ST(0) contains the real result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Pops pointer to string off the stack.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some real number.
Note:	AtofStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<A NAME=HEADING1-86></A>
<HR>
<H2>6.3.2  Atof Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Atof Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Atof<TD>X<TD>X<TD>&nbsp;<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-88></A>
<HR>
<H2>6.3.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;  -12345.67  89.1e-10&quot;,0
Value           real8   ?
Value2          real8   ?
                 
                lesi    String2Convert
                atof
                fst     Value          ;Value = -12345.67
                 
                atofCS
                dword   String2Convert
                fst     Value          ;Value = -12345.67

                push    seg String2Convert
                push    offset String2Convert
                atofStk
                fst     Value           ;Value = -12345.67
                
                lesi    String2Convert
                atofx
                fst     Value           ;Value = -12345.67
                atofx
                fst     Value2          ;Value2 = 89.1e-10

</PRE>
<A NAME=HEADING1-112></A>
<HR>
<H1>6.4  Atoh, AtohCS, Atohx, AtohStk, AtohTOS</H1>
 These routines convert a string of ASCII characters that represent a hexadecimal value to a 16-bit value in the range 0..FFFF.   The regular expression for legal values is<P>
<PRE>
[&quot;0&quot;..&quot;9&quot; | &quot;A&quot;..&quot;f&quot; | &quot;a&quot;..&quot;f&quot;] 
	[[&quot;0&quot;..&quot;9&quot; | &quot;a&quot;..&quot;f&quot; | &quot;a&quot;..&quot;f&quot; | &quot;_&quot;]* 
		[&quot;0&quot;..&quot;9&quot; | &quot;a&quot;..&quot;f&quot; | &quot;a&quot;..&quot;f&quot;]]*

</PRE>
 In English, this regular expression requires at least one hexadecimal digit followed by zero or more hexadecimal digits.  It also allows underscore characters between hex digits (though not at the beginning or end of the value).<P>
 Other than the fact that these routines work with hexadecimal values, you use them in the same manner that you would use the ATOI* routines. <P>
<A NAME=HEADING1-120></A>
<HR>
<H2>6.4.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Atoh</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some hexadecimal number.
Note:	Atoh will skip leading spaces in the string before the conversion begins.

<B>Atohx</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Does not preserve DI.  Assuming C=0 upon return, DI will point at the first non-hex digit (and non-underscore) character in the string.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some hexadecimal number.
Note:	Atohx will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtohCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	AX contains the result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
Note:	AtohCS will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtohStk</B>:
Inputs:	A far pointer to the string to convert (pushed first) and a far pointer to the word that will hold the result (pushed second) appear on the top of stack.
Outputs:	AtohStk stores the converted result at the specified address.
Errors:	None.
Side Effects:	Pops the two pointers off the stack.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some hexadecimal number.
Note:	AtohStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtohTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	AtohTOS leaves the converted result on the top of the stack.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtohTOS will skip leading spaces in the string before the conversion begins.
</PRE>
<A NAME=HEADING1-160></A>
<HR>
<H2>6.4.2  Atoh Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Atoh Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Atoh<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 The Atoh macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Atoh Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoh<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Atoh Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoh<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Atoh Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoh<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-168></A>
<HR>
<H2>6.4.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;  ABCD  678a&quot;,0
Value           word    ?
Value2          word    ?
wPtr            word    String2Convert
dPtr            dword   String2Convert

                lesi    String2Convert
                Atoh
                mov     Value, ax       ;Value = 0abcdh

                AtohCS
                dword   String2Convert
                mov     Value, ax       ;Value = 0abcdh

                pshadrs String2Convert
                AtohTOS
                pop     Value           ;Value = 0abcdh

                pshadrs String2Convert
                pshadrs Value
                AtohStk                 ;Value = 0abcdh

                lesi    String2Convert
                Atohx
                mov     Value, ax       ;Value = 0abcdh
                Atohx
                mov     Value2, ax      ;Value2 = 678ah
                
</PRE>
 The Atoh routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Atoh calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Atoh routine;  it expects a pointer to the string in ES:DI and returns the converted result in AX:<P>
<PRE>
                Atoh   ;Generates a call to the stdlib $Atoh routine.

</PRE>
 The second version of the extended syntax Atoh call lets you specify a single parameter.  If this is the name of a byte variable,  Atoh assumes this is the name of a string variable that contains the value to convert.  It calls AtohCS to do the conversion and returns the value in AX:<P>
<PRE>
                Atoh    String2Convert

; Equivalent to:

                AtohCS
                dword   String2Convert
</PRE>
 If this is a [wvar] or [dwvar] operand (word pointer or double word pointer), then atoh assumes the pointer contains the address of the string to convert.  Atoh will return the converted value in AX.<P>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where Atoh will put the result.  This particular form calls the AtohStk routine:<P>
<PRE>
                Atoh    byteVar, wordVar
                Atoh    byteVar, [wordVar]
                Atoh    byteVar, [dwordVar]

                Atoh    [wordVar], wordVar
                Atoh    [wordVar], [wordVar]
                Atoh    [wordVar], [dwordVar]

                Atoh    [dwordVar], wordVar
                Atoh    [dwordVar], [wordVar]
                Atoh    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, Atoh assumes that it's the name of a string variable.  It converts that string to a binary value.  If the first parameter is of the form &quot;[wordVar]&quot; then Atoh assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to a binary value.  If the first parameter is &quot;[dwordVar]&quot; then Atoh assumes this is a dword variable containing a far pointer to the string, it converts that string to a binary value.<P>
 The second parameter must be a word variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  Atoh stores the converted value in the word specified by this second parameter. <P>
 Note that Atoh converts all the calls above to AtohStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls AtohStk to do the work.<P>
 <P>
<A NAME=HEADING1-226></A>
<HR>
<H1>6.5  Atoi, AtoiCS, AtoiStk, AtoiTOS, AtoiX</H1>
 These routines convert a string of ASCII characters to a 16-bit signed integer value.  On entry to Atoi and Atoix, the ES:DI register pair contains the address of the string to convert;  on entry to AtoiStk, the far address of the string appears on the stack.  AtoiCS expects a pointer to a string in the code stream immediately following the call.   AtoiStk expects two pointers on the stack, a pointer to the string to convert and a pointer to the integer where it should store the result.  AtoiTOS expects a pointer to a string on the top of stack, it leaves the integer result on the stack.<P>
 On return from the Atoi, AtoiX, and AtoiCS routines, the AX register contains the signed integer value assuming there was no conversion error.  AtoiStk and AtoiTOS leave their results in the aforementioned locations. If a conversion error occurs, these routines return the carry flag set.  If no such error occurs, these routines return the carry flag clear.  <P>
 These routines are rather lax in their conversion.  Specifically, they allow leading spaces and will terminate conversion on the first non-digit symbol.  Assuming there was at least one decimal digit in the string, they will not return an error. <P>
 These routines flag an error under under two conditions: an arithmetic overflow occurs during conversion or if the first non-blank character is not a digit or a minus sign followed by a digit.  Arithmetic overflow occurs if the value is outside the range -32768..+32767.  A valid number takes the form described by the following regular expression:<P>
<PRE>
	[&quot;-&quot; | ] [&quot;0&quot;..&quot;9&quot;] [[&quot;0&quot;..&quot;9&quot; | &quot;_&quot;]* [&quot;0&quot;..&quot;9&quot;]]*

</PRE>
 In English, this regular expression means that a 16-bit signed value may have an optional minus sign followed by at least one digit.  It may optionally have more than one decimal digit.  If the number contains two or more digits, there may be underscore characters between the digits (that is, the digit string cannot begin or end with the underscore).  The conversion algorithm ignores any underscores appearing in the string.  They are intended to serve as thousands separators in lieu of commas in long numbers.  There is no requirement that they occur within an integer nor any requirement that they separate exactly three digits.  The following &quot;integers&quot; all represent the same value:<P>
<PRE>
	-1000	-1_000	-1_0_0_0		-1_____000

</PRE>
 If you need to verify that the conversion did not end on an illegal symbol, you should use the Atoix routine.  This routine leaves ES:DI pointing at the first character it was not able to convert (assuming Atoix returns with the carry flag clear).  You can compare the character ES:DI points at against a set of legal characters that you want to allow as number termination characters.<P>
<A NAME=HEADING1-237></A>
<HR>
<H2>6.5.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Atoi</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the signed result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atoi will skip leading spaces in the string before the conversion begins.

<B>Atoix</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the signed result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Does not preserve DI.  Assuming C=0 upon return, DI will point at the first non-digit character in the string.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atoix will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoiCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	AX contains the signed result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
Note:	AtoiCS will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoiStk</B>:
Inputs:	A far pointer to the string to convert (pushed first) and a far pointer to the word that will hold the result (pushed second) appear on the top of stack.
Outputs:	AtoiStk stores the converted result at the specified address.
Errors:	None.
Side Effects:	Pops the two pointers off the stack.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtoiStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoiTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	AtoiTOS leaves the converted result on the top of the stack.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtoiTOS will skip leading spaces in the string before the conversion begins.
</PRE>
<A NAME=HEADING1-277></A>
<HR>
<H2>6.5.2  Atoi Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Atoi Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Atoi<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 The Atoi macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Atoi Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoi<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Atoi Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoi<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Atoi Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoi<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-285></A>
<HR>
<H2>6.5.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;  -12345  6789&quot;,0
Value           word    ?
Value2          word    ?
wPtr            word    String2Convert
dPtr            dword   String2Convert

                lesi    String2Convert
                atoi
                mov     Value, ax       ;Value = -12345

                atoiCS
                dword   String2Convert
                mov     Value, ax       ;Value = -12345

                pshadrs String2Convert
                atoiTOS
                pop     Value           ;Value = -12345

                pshadrs String2Convert
                pshadrs Value
                atoiStk                 ;Value = -12345

                lesi    String2Convert
                atoix
                mov     Value, ax       ;Value = -12345
                atoix
                mov     Value2, ax      ;Value2 = 6789
                
</PRE>
 The Atoi routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Atoi calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Atoi routine;  it expects a pointer to the string in ES:DI and returns the converted result in AX:<P>
<PRE>
                atoi      ;Generates a call to the stdlib $atoi routine.

</PRE>
 The second version of the extended syntax Atoi call lets you specify a single parameter.  This must be the name of a byte variable.  Atoi assumes this is the name of a string variable that contains the value to convert.  It calls AtoiCS to do the conversion and returns the value in AX:<P>
<PRE>
                atoi    String2Convert

; Equivalent to:

                atoiCS
                dword   String2Convert

</PRE>
 Another possibility is to specify (surrounded by square brackets) the name of a word or dword pointer variable that contains the near or far address (respectively) of the string to convert.<P>
<PRE>

		atoi	[wptr]
		atoi	[dptr]

</PRE>
 The first example above assumes that wptr contains a near pointer to a character string found in the current data segment.  The second example uses a far pointer to the string.<P>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where Atoi will put the result.  This particular form calls the AtoiStk routine:<P>
<PRE>
                atoi    byteVar, wordVar
                atoi    byteVar, [wordVar]
                atoi    byteVar, [dwordVar]

                atoi    [wordVar], wordVar
                atoi    [wordVar], [wordVar]
                atoi    [wordVar], [dwordVar]

                atoi    [dwordVar], wordVar
                atoi    [dwordVar], [wordVar]
                atoi    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, Atoi assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then Atoi assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then Atoi assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a word variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  Atoi stores the converted integer in the word specified by this second parameter. <P>
 Note that Atoi converts all the calls above to AtoiStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls AtoiStk to do the work.<P>
<A NAME=HEADING1-348></A>
<HR>
<H1>6.6  AtoL, AtoLCS, AtoLx, AtoLStk, AtoLTOS</H1>
 These routines convert a string of ASCII characters to a 32-bit signed integer value in the range -2147483648..+2147483647.   Other than the range involved, this routine is identical to the Atoix routines.  Please see their descriptions for more details. <P>
<A NAME=HEADING1-350></A>
<HR>
<H2>6.6.1  Calling Conventions and Assertions</H2>
<PRE>
<B>AtoL</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the signed result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atol will skip leading spaces in the string before the conversion begins.

<B>AtoLx</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the signed result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Does not preserve DI.  Assuming C=0 upon return, DI will point at the first non-digit character in the string.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atolx will skip leading spaces in the string before the conversion begins.

<B>AtoLCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
Note:	AtoLCS will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoLStk</B>:
Inputs:	A far pointer to the string to convert (pushed first) and a far pointer to the word that will hold the result (pushed second) appear on the top of stack.
Outputs:	AtoLStk stores the converted result at the specified address.
Errors:	None.
Side Effects:	Pops the two pointers off the stack.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtoLStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoLTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	AtoLTOS replaces the pointer on TOS with the converted result.
Errors:	None.
Side Effects:	None.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtoLTOS will skip leading spaces in the string before the conversion begins.
</PRE>
<A NAME=HEADING1-390></A>
<HR>
<H2>6.6.2  AtoL Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>AtoL  Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>AtoL<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 The Atol macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Atol Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atol<TD>X<TD>X<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Atol Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atol<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Atol Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atol<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-398></A>
<HR>
<H2>6.6.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;  12345  6789&quot;,0
Value           sdword    ?
Value2          sdword    ?
wPtr            word    String2Convert
dPtr            dword   String2Convert

                lesi    String2Convert
                atol
                mov     Value, eax       ;Value = 12345

                atolCS
                dword   String2Convert
                mov     Value, eax       ;Value = 12345

                pshadrs String2Convert
                atolTOS
                popd    Value           ;Value = 12345

                pshadrs String2Convert
                pshadrs Value
                atolStk                 ;Value = 12345

                lesi    String2Convert
                atolx
                mov     Value, eax      ;Value = 12345
                atolx
                mov     Value2, eax     ;Value2 = 6789
                
</PRE>
 The Atol routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Atol calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Atol routine;  it expects a pointer to the string in ES:DI and returns the converted result in EAX:<P>
<PRE>
                atol       ;Generates a call to the stdlib $atol routine.

</PRE>
 The second version of the extended syntax Atol call lets you specify a single parameter.  This must be the name of a byte variable.  Atol assumes this is the name of a string variable that contains the value to convert.  It calls AtolCS to do the conversion and returns the value in EAX:<P>
<PRE>
                atol    String2Convert

; Equivalent to:

                atolCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where Atol will put the result.  This particular form calls the AtolStk routine:<P>
<PRE>
                atol    byteVar, dwordVar
                atol    byteVar, [wordVar]
                atol    byteVar, [dwordVar]

                atol    [wordVar], dwordVar
                atol    [wordVar], [wordVar]
                atol    [wordVar], [dwordVar]

                atol    [dwordVar], dwordVar
                atol    [dwordVar], [wordVar]
                atol    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, Atol assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then Atol assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then Atol assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a dword variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  Atol stores the converted integer in the  dword specified by this second parameter. <P>
 Note that Atol converts all the calls above to AtolStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls AtolStk to do the work.<P>
 <P>
<A NAME=HEADING1-456></A>
<HR>
<H1>6.7  Atolh, Atolhx, AtolhStk, AtolhTOS</H1>
 These routines convert a string of ASCII characters that represent a hexadecimal value to a 32-bit value in the range 0..FFFFFFFF.   The regular expression for legal values is<P>
<PRE>
[&quot;0&quot;..&quot;9&quot; | &quot;A&quot;..&quot;f&quot; | &quot;a&quot;..&quot;f&quot;] 
	[[&quot;0&quot;..&quot;9&quot; | &quot;a&quot;..&quot;f&quot; | &quot;a&quot;..&quot;f&quot; | &quot;_&quot;]* 
		[&quot;0&quot;..&quot;9&quot; | &quot;a&quot;..&quot;f&quot; | &quot;a&quot;..&quot;f&quot;]]*

</PRE>
 In English, this regular expression requires at least one hexadecimal digit followed by zero or more hexadecimal digits.  It also allows underscore characters between hex digits (though not at the beginning or end of the value).<P>
  These routines are essentially the same as the Atoh* routines except they return a 32-bit value in EAX rather than a 16-bit value in AX.<P>
<A NAME=HEADING1-464></A>
<HR>
<H2>6.7.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Atolh</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some hexadecimal number.
Note:	Atolh will skip leading spaces in the string before the conversion begins.

<B>Atolhx</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Does not preserve DI.  Assuming C=0 upon return, DI will point at the first non-hex digit (and non-underscore) character in the string.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some hexadecimal number.
Note:	Atolhx will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtolhCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	EAX contains the result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
Note:	AtolhCS will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtolhStk</B>:
Inputs:	A far pointer to the string to convert (pushed first) and a far pointer to the word that will hold the result (pushed second) appear on the top of stack.
Outputs:	AtolhStk stores the converted result at the specified address.
Errors:	None.
Side Effects:	Pops the two pointers off the stack.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some hexadecimal number.
Note:	AtolhStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtolhTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	AtolhTOS leaves the converted result on the top of the stack.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtolhTOS will skip leading spaces in the string before the conversion begins.
</PRE>
<A NAME=HEADING1-504></A>
<HR>
<H2>6.7.2  Atolh Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Atolh Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Atolh<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 The Atolh macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Atolh Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>No Operand<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atolh<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Atolh Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atolh<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Atolh Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atolh<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-512></A>
<HR>
<H2>6.7.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;  1a2b  6789&quot;,0
Value           dword   ?
Value2          dword   ?
wPtr            word    String2Convert
dPtr            dword   String2Convert

                lesi    String2Convert
                Atolh
                mov     Value, eax      ;Value = 1a2b

                AtolhCS
                dword   String2Convert
                mov     Value, eax      ;Value = 1a2b

                pshadrs String2Convert
                AtolhTOS
                popd     Value          ;Value = 1a2b

                pshadrs String2Convert
                pshadrs Value
                AtolhStk                ;Value = 1a2b

                lesi    String2Convert
                Atolhx
                mov     Value, eax      ;Value = 1a2b
                Atolhx
                mov     Value2, eax     ;Value2 = 6789
                
</PRE>
 The Atolh routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Atolh calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Atolh routine;  it expects a pointer to the string in ES:DI and returns the converted result in EAX:<P>
<PRE>
                Atolh                   ;Generates a call to the stdlib $Atolh routine.

</PRE>
 The second version of the extended syntax Atolh call lets you specify a single parameter.  This must be the name of a byte variable.  Atolh assumes this is the name of a string variable that contains the value to convert.  It calls AtolhCS to do the conversion and returns the value in EAX:<P>
<PRE>
                Atolh    String2Convert

; Equivalent to:

                AtolhCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where Atolh will put the result.  This particular form calls the AtolhStk routine:<P>
<PRE>
                Atolh    byteVar, dwordVar
                Atolh    byteVar, [wordVar]
                Atolh    byteVar, [dwordVar]

                Atolh    [wordVar], dwordVar
                Atolh    [wordVar], [wordVar]
                Atolh    [wordVar], [dwordVar]

                Atolh    [dwordVar], dwordVar
                Atolh    [dwordVar], [wordVar]
                Atolh    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, Atolh assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then Atolh assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then Atolh assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a dword variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  Atolh stores the converted integer in the dword specified by this second parameter. <P>
 Note that Atolh converts all the calls above to AtolhStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls AtolhStk to do the work.<P>
<PRE>

</PRE>
<A NAME=HEADING1-570></A>
<HR>
<H1>6.8  Atou, AtouCS, AtouTOS, AtouStk, Atoux</H1>
 These routines convert a string of ASCII characters to a 16-bit unsigned integer value in the range 0..65535.  You use these routines in a manner identical to the Atoix  routines except that these routines do not allow a leading minus sign in front of the number and they allow positive values in the range 32768..65535.  The regular expression for legal values is<P>
<PRE>
	[&quot;0&quot;..&quot;9&quot;] [[&quot;0&quot;..&quot;9&quot; | &quot;_&quot;]* [&quot;0&quot;..&quot;9&quot;]]*
</PRE>
 <P>
<A NAME=HEADING1-574></A>
<HR>
<H2>6.8.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Atou</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atou will skip leading spaces in the string before the conversion begins.

<B>Atoux</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Does not preserve DI.  Assuming C=0 upon return, DI will point at the first non-digit (and non-underscore) character in the string.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atoux will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtouCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	AX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
Note:	AtouCS will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtouStk</B>:
Inputs:	A far pointer to the string to convert (pushed first) and a far pointer to the word that will hold the result (pushed second) appear on the top of stack.
Outputs:	AtouStk stores the converted result at the specified address.
Errors:	None.
Side Effects:	Pops the two pointers off the stack.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtouStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtouTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	AtouTOS leaves the converted result on the top of the stack.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtouTOS will skip leading spaces in the string before the conversion begins.
</PRE>
<A NAME=HEADING1-614></A>
<HR>
<H2>6.8.2  Atou Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Atou Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Atou<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 The Atou macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Atou Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>No Operand<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atou<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Atou Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atou<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Atou Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atou<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-622></A>
<HR>
<H2>6.8.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;  12345  6789&quot;,0
Value           word    ?
Value2          word    ?
wPtr            word    String2Convert
dPtr            dword   String2Convert

                lesi    String2Convert
                atou
                mov     Value, ax       ;Value = 12345

                atouCS
                dword   String2Convert
                mov     Value, ax       ;Value = 12345

                pshadrs String2Convert
                atouTOS
                pop     Value           ;Value = 12345

                pshadrs String2Convert
                pshadrs Value
                atouStk                 ;Value = 12345

                lesi    String2Convert
                atoux
                mov     Value, ax       ;Value = 12345
                atoux
                mov     Value2, ax      ;Value2 = 6789
                
</PRE>
 The Atou routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Atou calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Atou routine;  it expects a pointer to the string in ES:DI and returns the converted result in AX:<P>
<PRE>
                atou     ;Generates a call to the stdlib $atou routine.

</PRE>
 The second version of the extended syntax Atou call lets you specify a single parameter.  This must be the name of a byte variable, a [word] pointer, or a [dword] pointer.  For byte variables,  it calls AtouCS to do the conversion and returns the value in AX:<P>
<PRE>
                atou    String2Convert

; Equivalent to:

                atouCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where Atou will put the result.  This particular form calls the AtouStk routine:<P>
<PRE>
                atou    byteVar, wordVar
                atou    byteVar, [wordVar]
                atou    byteVar, [dwordVar]

                atou    [wordVar], wordVar
                atou    [wordVar], [wordVar]
                atou    [wordVar], [dwordVar]

                atou    [dwordVar], wordVar
                atou    [dwordVar], [wordVar]
                atou    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, Atou assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then Atou assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then Atou assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a word variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  Atou stores the converted integer in the word specified by this second parameter. <P>
 Note that Atou converts all the calls above to AtouStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls AtouStk to do the work.<P>
<A NAME=HEADING1-679></A>
<HR>
<H1>6.9  Atoul, AtoulCS, Atoulx, AtoulStk, AtoulTOS</H1>
 These routines convert a string of ASCII characters to a 32-bit unsigned integer value in the range 0..4294967295.  You use these routines in a manner identical to the Atoux  routines except they input 32-bit integers rather than 16-bit integers.  See Atoux for more details.<P>
<A NAME=HEADING1-681></A>
<HR>
<H2>6.9.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Atoul</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atoul will skip leading spaces in the string before the conversion begins.

<B>Atoulx</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	Does not preserve DI.  Assuming C=0 upon return, DI will point at the first non-digit (and non-underscore) character in the string.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.
Note:	Atoulx will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoulCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
Note:	AtoulCS will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoulStk</B>:
Inputs:	A far pointer to the string to convert (pushed first) and a far pointer to the word that will hold the result (pushed second) appear on the top of stack.
Outputs:	AtoulStk stores the converted result at the specified address.
Errors:	None.
Side Effects:	Pops the two pointers off the stack.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtoulStk will skip leading spaces in the string before the conversion begins.
</PRE>
 <P>
<PRE>
<B>AtoulTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	AtoulTOS leaves the converted result on the top of the stack.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.
Note:	AtoulTOS will skip leading spaces in the string before the conversion begins.
</PRE>
<A NAME=HEADING1-721></A>
<HR>
<H2>6.9.2  Atoul Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Atoul Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Atoul<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 The Atoul macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Atoul Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoul<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Atoul Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoul<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Atoul Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Atoul<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-729></A>
<HR>
<H2>6.9.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;  12345  6789&quot;,0
Value           dword   ?
Value2          dword   ?
wPtr            word    String2Convert
dPtr            dword   String2Convert

                lesi    String2Convert
                atoul
                mov     Value, eax      ;Value = 12345

                atoulCS
                dword   String2Convert
                mov     Value, eax      ;Value = 12345

                pshadrs String2Convert
                atoulTOS
                popd     Value          ;Value = 12345

                pshadrs String2Convert
                pshadrs Value
                atoulStk                ;Value = 12345

                lesi    String2Convert
                atoulx
                mov     Value, eax      ;Value = 12345
                atoulx
                mov     Value2, eax     ;Value2 = 6789
                
</PRE>
 The Atoul routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Atoul calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Atoul routine;  it expects a pointer to the string in ES:DI and returns the converted result in EAX:<P>
<PRE>
                atoul                   ;Generates a call to the stdlib $atoul routine.

</PRE>
 The second version of the extended syntax Atoul call lets you specify a single parameter.  This must be the name of a byte variable.  Atoul assumes this is the name of a string variable that contains the value to convert.  It calls AtoulCS to do the conversion and returns the value in EAX:<P>
<PRE>
                atoul    String2Convert

; Equivalent to:

                atoulCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where Atoul will put the result.  This particular form calls the AtoulStk routine:<P>
<PRE>
                atoul    byteVar, dwordVar
                atoul    byteVar, [wordVar]
                atoul    byteVar, [dwordVar]

                atoul    [wordVar], dwordVar
                atoul    [wordVar], [wordVar]
                atoul    [wordVar], [dwordVar]

                atoul    [dwordVar], dwordVar
                atoul    [dwordVar], [wordVar]
                atoul    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, Atoul assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then Atoul assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then Atoul assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a dword variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  Atoul stores the converted integer in the dword specified by this second parameter. <P>
 Note that Atoul converts all the calls above to AtoulStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls AtoulStk to do the work.<P>
<PRE>

</PRE>
<A NAME=HEADING1-787></A>
<HR>
<H1>6.10  etoa, etoax, etoam</H1>
 These routines convert a floating point number to the ASCII representation of that value in scientific notation.<P>
<A NAME=HEADING1-789></A>
<HR>
<H2>6.10.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Etoa</B>:
Inputs:	ST(0) contains the floating point value to convert. AL contians the number of print positions. ES:DI points at the buffer where Etoa will store its result.
Outputs:	The specified buffer holds a zero terminated string containing the result.
Errors:	If the number does not fit in the output buffer (i.e., if AL contains less than eight), then this functions writes pound signs (&quot;#&quot;) to the buffer.
Side Effects:	None.
Assertions:	ES:DI points at a buffer with at least AL+1 available bytes.

<B>Etoam</B>:
Inputs:	ST(0) contains the floating point value to convert. AL contians the number of print positions
Outputs:	Etoam allocates storage for the resulting string on the heap  and returns a pointer to this converted string in ES:DI.
Errors:	If the number does not fit in the output buffer (i.e., if AL contains less than eight), then this functions writes pound signs (&quot;#&quot;) to the buffer.  If insufficient memory is available on the heap, this function will raise an exception (assuming exceptions are enabled).
Side Effects:	None.
Assertions:	Sufficient memory exists on the heap.

<B>Etoax:</B>
Inputs:	ST(0) contains the floating point value to convert. AL contians the number of print positions. ES:DI points at the buffer where Etoa will store its result.
Outputs:	The specified buffer holds a zero terminated string containing the result.
Errors:	If the number does not fit in the output buffer (i.e., if AL contains less than eight), then this functions writes pound signs (&quot;#&quot;) to the buffer.
Side Effects:	Etoax does not preserve the ES:DI register.  It leaves DI pointing at the zero byte immediately after the converted string.
Assertions:	ES:DI points at a buffer with at least AL+1 available bytes.

</PRE>
<A NAME=HEADING1-811></A>
<HR>
<H2>6.10.2  Etoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Etoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Etoa<TD>X<TD>-<TD>-<TD>-<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 Etoa does not provide an extended syntax.<P>
<A NAME=HEADING1-815></A>
<HR>
<H2>6.10.3  Syntax &amp; Examples</H2>
<PRE>
fVar            real8   3.14159
eVar            real8   2.71

fMsg            byte    &quot;PI and E = &quot;
fStr            byte    32 dup (?)
                 .
                 .
                 .
                fld     fVar
                lesi    fStr
                mov     al, 12
                etoa
                printf  &quot;fStr = %s\n&quot;, fStr
                 .
                 .
                 .
                fld     fVar
                mov     al, 12
                etoam
                print   &quot;Value = &quot;
                puts
                putcr
                 .
                 .
                 .
                fld     fVar
                lesi    fStr
                mov     al, 12
                etoax
                mov     byte ptr es:[di],','
                inc     di
                fld     eVar
                mov     al, 12
                etoa
                
</PRE>
<A NAME=HEADING1-851></A>
<HR>
<H1>6.11  ftoa, ftoax, ftoam</H1>
 These routines convert a floating point number to the ASCII representation of that value in decimal notation.<P>
<A NAME=HEADING1-853></A>
<HR>
<H2>6.11.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Ftoa</B>:
Inputs:	ST(0) contains the floating point value to convert. AL contians the number of print positions. AH contains the number of print positions to the right of the decimal point. ES:DI points at the buffer where ftoa will store its result.
Outputs:	The specified buffer holds a zero terminated string containing the result.
Errors:	If the number does not fit in the output buffer, then this functions writes pound signs (&quot;#&quot;) to the buffer.
Side Effects:	None.
Assertions:	ES:DI points at a buffer with at least AL+1 available bytes.

<B>Ftoam</B>:
Inputs:	ST(0) contains the floating point value to convert. AL contains the number of print positions.  AH contains the number of positions after the decimal point.
Outputs:	Ftoam allocates storage for the resulting string on the heap  and returns a pointer to this converted string in ES:DI.
Errors:	If the number does not fit in the output buffer, then this functions writes pound signs (&quot;#&quot;) to the buffer.  If insufficient memory is available on the heap, this function will raise an exception (assuming exceptions are enabled).
Side Effects:	None.
Assertions:	There is a value on the floating point stack.

<B>Ftoax:</B>
Inputs:	ST(0) contains the floating point value to convert. AL contians the number of print positions. AH contains the number of print positions to the right of the decimal point.  ES:DI points at the buffer where Ftoa will store its result.
Outputs:	The specified buffer holds a zero terminated string containing the result.
Errors:	If the number does not fit in the output buffer (i.e., if AL contains less than eight), then this functions writes pound signs (&quot;#&quot;) to the buffer.
Side Effects:	Ftoax does not preserve the ES:DI register.  It leaves DI pointing at the zero byte immediately after the converted string.
Assertions:	ES:DI points at a buffer with at least AL+1 available bytes.  The floating point stack must contain a value.

</PRE>
<A NAME=HEADING1-875></A>
<HR>
<H2>6.11.2  Ftoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Ftoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Ftoa<TD>X<TD>-<TD>-<TD>-<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 Ftoa does not provide an extended syntax.<P>
<A NAME=HEADING1-879></A>
<HR>
<H2>6.11.3  Syntax &amp; Examples</H2>
<PRE>
fVar            real8   3.14159
eVar            real8   2.71

fMsg            byte    &quot;PI and E = &quot;
fStr            byte    32 dup (?)
                 .
                 .
                 .
                fld     fVar
                lesi    fStr
                mov     al, 8
                mov     ah, 5
                ftoa
                printf  &quot;fStr = %s\n&quot;, fStr
                 .
                 .
                 .
                fld     fVar
                mov     al, 8
                mov     ah, 5
                ftoam
                print   &quot;Value = &quot;
                puts
                putcr
                 .
                 .
                 .
                fld     fVar
                lesi    fStr
                mov     al, 8
                mov     ah, 5
                etoax
                mov     byte ptr es:[di],','
                inc     di
                fld     eVar
                mov     al, 9
                mov     ah, 5
                ftoa
                
</PRE>
<A NAME=HEADING1-919></A>
<HR>
<H1>6.12  Htoa, HtoaCS, HtoaStk, HtoaTOS, Htoax, Htoam</H1>
 These routines convert an 8-bit integer value to a string containing exactly two characters (plus a zero terminating byte).  The string is the hexadecimal representation of the unsigned integer value.  These routines print any necessary leading zeros;  the string is always exactly two characters long.<P>
<A NAME=HEADING1-921></A>
<HR>
<H2>6.12.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Htoa</B>:
Inputs:	AL contains the integer value to convert. ES:DI points at a string that can hold at least three bytes (two digits plus a zero terminating character).
Outputs:	Htoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at an array that can hold at least three bytes.

<B>Htoam</B>:
Inputs:	AL contains the integer value to convert.
Outputs:	Htoa stores the converted string onto the heap.  It returns a pointer to the string in the ES:DI register pair.
Errors:	The malloc routine raises an exception if there is insufficient room on the heap..
Side Effects:	None.
Assertions:	Sufficient memory is available on the heap.

<B>Htoax</B>:
Inputs:	AL contains the integer value to convert. ES:DI points at a string that can hold at least three bytes (two digits plus a zero terminating character).
Outputs:	Htoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	Does not preserve DI.  This routine leaves DI pointing at the zero byte at the end of the converted string.
Assertions:	ES:DI points at an array that can hold at least three bytes.

<B>HtoaCS</B>:
Inputs:	AL contains the eight-bit integer value to convert. A far pointer to a string buffer that will hold the result immediate follows the call in the code stream.
Outputs:	HtoaCS stores the converted string at the location pointed by the far pointer in the code stream.
Errors:	None.
Side Effects:	On return, HtoaCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.
Assertions:	The far pointer in the code stream points at an array that can hold at least three bytes.

<B>HtoaTOS</B>:
Inputs:	The TOS contains a 16-bit value.  HtoaTOS converts the L.O. byte of this 16-bit value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  HtoaTOS stores the converted string at this address.
Outputs:	HtoaTOS stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the value and far pointer off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least three bytes.

<B>HtoaSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at an eight-bit value in memory.  HtoaStk converts this value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  HtoaStk stores the converted string at this address.
Outputs:	HtoaStk stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the two far pointers off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least three bytes.

</PRE>
<A NAME=HEADING1-964></A>
<HR>
<H2>6.12.2  Htoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Htoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Htoa<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 The Htoa macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Htoa Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Htoa<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Htoa Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Htoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Htoa Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Htoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-973></A>
<HR>
<H2>6.12.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    32 dup (0)
Value           byte    0ABh
Value2          byte    67h
wPtr            word    Value
dPtr            dword   Value2

                mov     al, Value
                lesi    String2Convert
                htoax
                mov     byte ptr es:[di], ' '
                mov     al, Value2
                htoa
                printf  &quot;Str2Cnvrt=%s\n&quot;, String2Convert
                 .
                 .
                 .
                mov     al, Value
                htoaCS
                dword   String2Convert
                printf  &quot;Str2Cnvrt=%s\n&quot;, String2Convert
                 .
                 .
                 .
                pshadrs String2Convert
                push    word ptr Value2
                htoaStk
                printf  &quot;String2Convert=%s\n&quot;, String2Convert
                 .
                 .
                 .
                pshadrs String2Convert
                push    word ptr Value          ;Ignores H.O. byte
                htoaTOS
                printf  &quot;String2Convert=%s\n&quot;, String2Convert

</PRE>
 The Htoa routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Htoa calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard htoa routine;  it expects a pointer to the string in ES:DI and the value to convert in AL:<P>
<PRE>
                htoa   ;Generates a call to the stdlib $htoa routine.

</PRE>
 The second version of the extended syntax htoa call lets you specify a single string parameter (the value to convert is assumed to be in the AL register).  If this is the name of a byte variable,  htoa assumes this is the name of a string variable where it stores the converted string..  It calls htoaCS to do the conversion:<P>
<PRE>
                htoa    String2Convert

; Equivalent to:

                htoaCS
                dword   String2Convert
</PRE>
 If this is a [wvar] or [dwvar] operand (word pointer or double word pointer), then htoa assumes the specified variable is a pointer to the array that will hold the string.  In either case ([wordvar] or [dwordvar]) the macro pushes the far address onto the stack along with the value to convert and calls the htoaTOS routine to do the conversion.<P>
 The third extended syntax form allows two parameters.  The first specifies the value to convert, the second specifies the address where htot will store the converted string.  This particular form calls the htoaStk routine:<P>
<PRE>
;                       Value     string
;                       -------- ------------
                htoa    byteVar, byteVar
                htoa    byteVar, [wordVar]
                htoa    byteVar, [dwordVar]

                htoa    [wordVar], wordVar
                htoa    [wordVar], [wordVar]
                htoa    [wordVar], [dwordVar]

                htoa    [dwordVar], wordVar
                htoa    [dwordVar], [wordVar]
                htoa    [dwordVar], [dwordVar]

</PRE>
 The first parameter must be a byte variable or a pointer to a byte variable.  The second parameter must be a pointer to an array that has enough storage to hold three characters (two digits and a zero terminating byte).<P>
<A NAME=HEADING1-1037></A>
<HR>
<H1>6.13  ISize, ISizeCS, ISizeStk, ISizeTOS</H1>
 These routines determine the number of print positions a 16-bit integer will require on output.  The value these functions return include a print position for a minus sign if the number is negative.<P>
<A NAME=HEADING1-1039></A>
<HR>
<H2>6.13.1  Calling Conventions and Assertions</H2>
<PRE>
<B>ISize</B>:
Inputs:	AX contains the integer value test.
Outputs:	ISize returns the number of print positions in EAX (1-5).
Errors:	None.
Side Effects:	None.

<B>ISizeCS</B>:
Inputs:	A far pointer to a 16-bit signed integer value immediately follows the call in the code stream.
Outputs:	ISizeCS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	On return, ISizeCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.

<B>ISizeTOS</B>:
Inputs:	The TOS contains the signed 16-bit value to test.
Outputs:	ISizeTOS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

<B>ISizeSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 16-bit value in memory to test.
Outputs:	ISizeStk returns the size of the integer in the EAX register.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

</PRE>
<A NAME=HEADING1-1064></A>
<HR>
<H2>6.13.2  ISize Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ISize Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>ISize<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 The ISize macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ISize Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ISize<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-1070></A>
<HR>
<H2>6.13.3  Syntax &amp; Examples</H2>
 The following example demonstrates how to create left and right justified versions of an integer value for possible output:<P>
<PRE>
Value           word    123
ValPtr1         word    Value
ValPtr2         dword   Value
                 .
                 .
                 .

; Output an integer right justified in a field of 12 print positions
; (This is, essentially, how PutISize works).

                mov     ax, Value
                ISize
                add     ax, -12         ;Compute ISize(value) - 12.
                neg     ax              ;Compute 12-ISize(value).
                call    PrtSpcs
                puti    Value
                 .
                 .
                 .

; Output an integer left justified in a field of 12 print positions.

                mov     ax, Value
                puti
                ISize
                add     ax, -12         ;Compute ISize(value) - 12.
                neg     ax              ;Compute 12-ISize(value).
                call    PrtSpcs

</PRE>
 The ISize macro also supports an extended syntax.  Without any parameters, ISize simply calls the StdLib $ISize procedure.  With a word parameter, ISize calls the StdLib $ISizeCS procedure.  With a word pointer or dword pointer argument, ISize calls the StdLib $ISizeStk routine.<P>
<PRE>
                ISize                   ;Calls $ISize
                
;The following are equivalent:

                ISize   Value
                
                ISizeCS
                dword   Value
                
;The following are equivalent:

                ISize   [ValPtr1]
                
                push    ds
                push    ValPtr1
                ISizeStk
                
;The following are equivalent:

                ISize   [ValPtr2]
                
                pushd   ValPtr2
                ISizeStk
                  .
                  .
                  .
prtspcs         proc    near
                push    eax
                mov     cx, ax
                mov     al, ' '
                jcxz    psDone
PrtLp:          putc
                loop    PrtLp
psDone:         pop     eax
                ret
prtspcs         endp

</PRE>
<A NAME=HEADING1-1139></A>
<HR>
<H1>6.14  Itoa, ItoaCS, ItoaStk, ItoaTOS, Itoax, Itoam</H1>
 These routines convert a 16-bit integer value to a string of decimal characters (plus a zero terminating byte).  These routines supress any leading zeros unless, of course, the integer value is zero.  If the integer value is negative, these routines emit a leading minus sign.<P>
<A NAME=HEADING1-1141></A>
<HR>
<H2>6.14.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Itoa</B>:
Inputs:	AX contains the integer value to convert. ES:DI points at a string that can hold at least seven bytes (a possible minus sign, up to five digits, and a zero terminating character).
Outputs:	Itoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at an array that can hold at least seven bytes.

<B>Itoam</B>:
Inputs:	AX contains the integer value to convert.
Outputs:	Itoa stores the converted string onto the heap.  It returns a pointer to the string in the ES:DI register pair.
Errors:	The malloc routine raises an exception if there is insufficient room on the heap.
Side Effects:	None.
Assertions:	Sufficient memory is available on the heap.

<B>Itoax</B>:
Inputs:	AX contains the integer value to convert. ES:DI points at a string that can hold at least seven bytes (a minus sign, five digits, and a zero terminating byte).
Outputs:	Itoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	Does not preserve DI.  This routine leaves DI pointing at the zero byte at the end of the converted string.
Assertions:	ES:DI points at an array that can hold at least seven bytes.

<B>ItoaCS</B>:
Inputs:	AX contains the 16-bit integer value to convert. A far pointer to a string buffer that will hold the result immediately follows the call in the code stream.
Outputs:	ItoaCS stores the converted string at the location pointed by the far pointer in the code stream.
Errors:	None.
Side Effects:	On return, ItoaCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.
Assertions:	The far pointer in the code stream points at an array that can hold at least seven bytes.

<B>ItoaTOS</B>:
Inputs:	The TOS contains a 16-bit value.  ItoaTOS converts this 16-bit value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  ItoaTOS stores the converted string at this address.
Outputs:	ItoaTOS stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the value and far pointer off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least seven bytes.

<B>ItoaSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 16-bit value in memory.  ItoaStk converts this value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  ItoaStk stores the converted string at this address.
Outputs:	ItoaStk stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the two far pointers off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least seven bytes.

</PRE>
<A NAME=HEADING1-1184></A>
<HR>
<H2>6.14.2  Itoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Itoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Itoa<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 The Itoa macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Itoa Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Itoa<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Itoa Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>word var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Itoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Itoa Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Itoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-1193></A>
<HR>
<H2>6.14.3  Syntax &amp; Examples</H2>
<PRE>
ConvertedStr    byte    32 dup (0)
Value           word    -12345
Value2          word    4321
wPtr            word    Value
dPtr            dword   Value2
sptr            dword   ConvertedStr
                 .
                 .
                 .
                mov     ax, Value
                lesi    ConvertedStr
                itoa
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     ax, Value2
                itoam
                print   &quot;ConvertedStr=&quot;
                puts
                free
                putcr
                 .
                 .
                 .
                mov     ax, Value
                lesi    ConvertedStr
                itoax
                mov     byte ptr es:[di], ' '
                mov     ax, Value2
                itoax
                printf  &quot;Value &amp; value2 = %s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     ax, Value
                itoaCS
                dword   ConvertedStr
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                push    Value
                itoaTOS
                printf  &quot;Value=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                pshadrs Value2
                itoaStk
                printf  &quot;Value2=%s\n&quot;, ConvertedStr


</PRE>
 The Itoa routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Itoa calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard itoa routine;  it expects a pointer to the string in ES:DI and the value to convert in AX:<P>
<PRE>
                itoa   ;Generates a call to the stdlib $itoa routine.

</PRE>
 The second version of the extended syntax itoa call lets you specify a single string parameter (the value to convert is assumed to be in the AX register).  If this is the name of a byte variable,  itoa assumes this is the name of a string variable where it stores the converted string..  It calls itoaCS to do the conversion:<P>
<PRE>
                itoa    ConvertedStr

; Equivalent to:

                itoaCS
                dword   ConvertedStr
</PRE>
 If this is a [wvar] or [dwvar] operand (word pointer or double word pointer), then itoa assumes the specified variable is a pointer to the array that will hold the string.  In either case ([wordvar] or [dwordvar]) the macro pushes the far address onto the stack along with the value to convert and calls the itoaTOS routine to do the conversion.<P>
 The third extended syntax form allows two parameters.  The first specifies the value to convert, the second specifies the address where itoa will store the converted string.  This particular form calls the itoaStk routine:<P>
<PRE>
;                       Value     string
;                       -------- ------------
                itoa    byteVar, byteVar
                itoa    byteVar, [wordVar]
                itoa    byteVar, [dwordVar]

                itoa    [wordVar], wordVar
                itoa    [wordVar], [wordVar]
                itoa    [wordVar], [dwordVar]

                itoa    [dwordVar], wordVar
                itoa    [dwordVar], [wordVar]
                itoa    [dwordVar], [dwordVar]

</PRE>
 The first parameter must be a word variable or a pointer to a word variable.  The second parameter must be a pointer to an array that has enough storage to hold seven characters (a leading minus sign, five digits, and a zero terminating byte).<P>
<A NAME=HEADING1-1277></A>
<HR>
<H1>6.15  LSize, LSizeCS, LSizeStk, LSizeTOS</H1>
 These routines determine the number of print positions a 32-bit signed integer will require on output.  The value these functions return include a print position for a minus sign if the number is negative.<P>
<A NAME=HEADING1-1279></A>
<HR>
<H2>6.15.1  Calling Conventions and Assertions</H2>
<PRE>
<B>LSize</B>:
Inputs:	EAX contains the integer value test.
Outputs:	LSize returns the number of print positions in EAX (1-5).
Errors:	None.
Side Effects:	None.

<B>LSizeCS</B>:
Inputs:	A far pointer to a 32-bit signed integer value immediately follows the call in the code stream.
Outputs:	LSizeCS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	On return, LSizeCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.

<B>LSizeTOS</B>:
Inputs:	The TOS contains the signed 32-bit value to test.
Outputs:	LSizeTOS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

<B>LSizeSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 32-bit value in memory to test.
Outputs:	LSizeStk returns the size of the integer in the EAX register.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

</PRE>
<A NAME=HEADING1-1304></A>
<HR>
<H2>6.15.2  LSize Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>LSize Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>LSize<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 The LSize macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>LSize Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>LSize<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-1310></A>
<HR>
<H2>6.15.3  Syntax &amp; Examples</H2>
 The following example demonstrates how to create left and right justified versions of an integer value for possible output:<P>
<PRE>
Value           sdword  123
ValPtr1         word    Value
ValPtr2         dword   Value
                 .
                 .
                 .

; Output an integer right justified in a field of 12 print positions
; (This is, essentially, how PutLSize works).

                mov     eax, Value
                LSize
                add     ax, -12         ;Compute LSize(value) - 12.
                neg     ax              ;Compute 12-LSize(value).
                call    PrtSpcs
                putl    Value
                 .
                 .
                 .

; Output an integer left justified in a field of 12 print positions.

                mov     eax, Value
                putl
                LSize
                add     ax, -12         ;Compute LSize(value) - 12.
                neg     ax              ;Compute 12-LSize(value).
                call    PrtSpcs

</PRE>
 The LSize macro also supports an extended syntax.  Without any parameters, LSize simply calls the StdLib $LSize procedure.  With a word parameter, LSize calls the StdLib $LSizeCS procedure.  With a word pointer or dword pointer argument, LSize calls the StdLib $LSizeStk routine.<P>
<PRE>
                LSize                   ;Calls $LSize
                
;The following are equivalent:

                LSize   Value
                
                LSizeCS
                dword   Value
                
;The following are equivalent:

                LSize   [ValPtr1]
                
                push    ds
                push    ValPtr1
                LSizeStk
                
;The following are equivalent:

                LSize   [ValPtr2]
                
                pushd   ValPtr2
                LSizeStk
                  .
                  .
                  .
prtspcs         proc    near
                push    eax
                mov     cx, ax
                mov     al, ' '
                jcxz    psDone
PrtLp:          putc
                loop    PrtLp
psDone:         pop     eax
                ret
prtspcs         endp
</PRE>
<A NAME=HEADING1-1378></A>
<HR>
<H1>6.16  Ltoa, LtoaCS, LtoaStk, LtoaTOS, Ltoax, Ltoam</H1>
 These routines convert a 32-bit signed integer value to a string of decimal characters (plus a zero terminating byte).  These routines supress any leading zeros unless, of course, the integer value is zero.  If the integer value is negative, these routines emit a leading minus sign.<P>
<A NAME=HEADING1-1380></A>
<HR>
<H2>6.16.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Ltoa</B>:
Inputs:	EAX contains the integer value to convert. ES:DI points at a string that can hold at least 12 bytes (a possible minus sign, up to ten digits, and a zero terminating character).
Outputs:	Ltoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at an array that can hold at least 12 bytes.

<B>Ltoam</B>:
Inputs:	EAX contains the integer value to convert.
Outputs:	Ltoa stores the converted string onto the heap.  It returns a pointer to the string in the ES:DI register pair.
Errors:	The malloc routine raises an exception if there is insufficient room on the heap.
Side Effects:	None.
Assertions:	Sufficient memory is available on the heap.

<B>Ltoax</B>:
Inputs:	EAX contains the integer value to convert. ES:DI points at a string that can hold at least 12 bytes (a minus sign, ten digits, and a zero terminating byte).
Outputs:	Ltoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	Does not preserve DI.  This routine leaves DI pointing at the zero byte at the end of the converted string.
Assertions:	ES:DI points at an array that can hold at least 12 bytes.

<B>LtoaCS</B>:
Inputs:	EAX contains the 32-bit integer value to convert. A far pointer to a string buffer that will hold the result immediately follows the call in the code stream.
Outputs:	LtoaCS stores the converted string at the location pointed by the far pointer in the code stream.
Errors:	None.
Side Effects:	On return, LtoaCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.
Assertions:	The far pointer in the code stream points at an array that can hold at least 12 bytes.

<B>LtoaTOS</B>:
Inputs:	The TOS contains a 32-bit signed integer.  LtoaTOS converts this 32-bit value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  LtoaTOS stores the converted string at this address.
Outputs:	LtoaTOS stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the value and far pointer off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least 12 bytes.

<B>LtoaSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 32-bit signed integer value in memory. LtoaStk converts this value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  LtoaStk stores the converted string at this address.
Outputs:	LtoaStk stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the two far pointers off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least 12 bytes.

</PRE>
<A NAME=HEADING1-1423></A>
<HR>
<H2>6.16.2  Ltoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Ltoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Ltoa<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 The Ltoa macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Ltoa Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Ltoa<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Ltoa Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>word var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Ltoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Ltoa Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Ltoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-1432></A>
<HR>
<H2>6.16.3  Syntax &amp; Examples</H2>
<PRE>
ConvertedStr    byte    32 dup (0)
Value           sdword  -123456789
Value2          sdword  987654321
wPtr            word    Value
dPtr            dword   Value2
sptr            dword   ConvertedStr
                 .
                 .
                 .
                mov     eax, Value
                lesi    ConvertedStr
                ltoa
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     eax, Value2
                ltoam
                print   &quot;ConvertedStr=&quot;
                puts
                free
                putcr
                 .
                 .
                 .
                mov     eax, Value
                lesi    ConvertedStr
                ltoax
                mov     byte ptr es:[di], ' '
                mov     eax, Value2
                ltoax
                printf  &quot;Value &amp; value2 = %s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     eax, Value
                ltoaCS
                dword   ConvertedStr
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                push    Value
                ltoaTOS
                printf  &quot;Value=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                pshadrs Value2
                ltoaStk
                printf  &quot;Value2=%s\n&quot;, ConvertedStr


</PRE>
 The Ltoa routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Ltoa calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Ltoa routine;  it expects a pointer to the string in ES:DI and the value to convert in EAX:<P>
<PRE>
                ltoa   ;Generates a call to the stdlib $ltoa routine.

</PRE>
 The second version of the extended syntax Ltoa call lets you specify a single string parameter (the value to convert is assumed to be in the EAX register).  If this is the name of a byte variable,  ltoa assumes this is the name of a string variable where it stores the converted string..  It calls LtoaCS to do the conversion:<P>
<PRE>
                ltoa    ConvertedStr

; Equivalent to:

                ltoaCS
                dword   ConvertedStr
</PRE>
 If this is a [wvar] or [dwvar] operand (word pointer or double word pointer), then ltoa assumes the specified variable is a pointer to the array that will hold the string.  In either case ([wordvar] or [dwordvar]) the macro pushes the far address onto the stack along with the value to convert and calls the ltoaTOS routine to do the conversion.<P>
 The third extended syntax form allows two parameters.  The first specifies the value to convert, the second specifies the address where ltoa will store the converted string.  This particular form calls the ltoaStk routine:<P>
<PRE>
;                       Value     string
;                       -------- ------------
                ltoa    byteVar, byteVar
                ltoa    byteVar, [wordVar]
                ltoa    byteVar, [dwordVar]

                ltoa    [wordVar], wordVar
                ltoa    [wordVar], [wordVar]
                ltoa    [wordVar], [dwordVar]

                ltoa    [dwordVar], wordVar
                ltoa    [dwordVar], [wordVar]
                ltoa    [dwordVar], [dwordVar]

</PRE>
 The first parameter must be a word variable or a pointer to a word variable.  The second parameter must be a pointer to an array that has enough storage to hold 12 characters (a leading minus sign, ten digits, and a zero terminating byte).<P>
<A NAME=HEADING1-1516></A>
<HR>
<H1>6.17  toFlt, toFltStk,toFltCS</H1>
 These routines are very similar to Atof, Atofx, and AtofStk.  There are three primary differences between the toFlt* and the Atof* routines:<P>
<PRE>
(1)	The Atof* routines are sloppy.  They allow leading spaces and allow the number to end with any arbitrary non-digit character.  The toFlt* routines are more rigorous in their checking.  In particular, the characters that appear in the string must be part of the number.  The conversion must end on a zero terminating byte, not an arbitrary character.

(2)	If exceptions are initialized and enabled, these routines generate a conversion exception when an error occurs.

(3)	There is no need for a toFltx routine because of point (1) above.  Leaving the ES:DI register pair pointing at the zero terminating byte would be of little use.
</PRE>
<A NAME=HEADING1-1523></A>
<HR>
<H2>6.17.1  Calling Conventions and Assertions</H2>
<PRE>
<B>toFlt</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	ST(0)  contains the real result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some real number.

<B>toFltStk</B>:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	ST(0)  contains the real result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Pops pointer to string off the stack. Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some real number.

<B>ToFltCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	ST(0) contains the floating point result. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the address of an ASCII representation of some number.
</PRE>
<A NAME=HEADING1-1544></A>
<HR>
<H2>6.17.2  ToFlt Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ToFlt Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>ToFlt<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The ToFlt macro does not provide any extended syntax:<P>
<A NAME=HEADING1-1548></A>
<HR>
<H2>6.17.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;-12345.6789&quot;,0
BadString       byte    &quot;ABCD&quot;,0
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                lesi    String2Convert
                toFlt
                mov     ax, 40Bh
                putf                    ;Prints -12345.6789
                putcr
                 .
                 .
                 .
                try
                 .
                 .
                 .
                lesi    BadString
                toFlt                   ;Raises an exception,
                putf                    ; does not print
                putcr                   ; anything here.
                 .
                 .
                 .
                exception $Conversion
                print   &quot;Conversion error occured&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx
                
</PRE>
<A NAME=HEADING1-1588></A>
<HR>
<H1>6.18  toHex, toHexStk, toHexTOS, toHexCS</H1>
 These routines are very similar to Atoh and AtohStk.  There are three primary differences between the toHex* and the Atoh* routines:<P>
<PRE>
(1)	The Atoh* routines are sloppy.  They allow leading spaces and allow the number to end with any arbitrary non-digit character.  The toHex* routines are more rigorous in their checking.  In particular, the characters that appear in the string must be part of the number.  The conversion must end on a zero terminating byte, not an arbitrary character.

(2)	If exceptions are initialized and enabled, these routines generate a conversion exception when an error occurs.

(3)	There is no need for a toHexx routine because of point (1) above.  Leaving the ES:DI register pair pointing at the zero terminating byte would be of little use.
</PRE>
<A NAME=HEADING1-1595></A>
<HR>
<H2>6.18.1  Calling Conventions and Assertions</H2>
<PRE>
<B>toHex</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the hexadecimal result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.

<B>toHexStk</B>:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	AX contains the hexadecimal result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Pops pointer to string off the stack. Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToHexTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	ToHexTOS leaves the converted result on the top of the stack. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToHexCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	AX contains the signed result. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
</PRE>
 <P>
<A NAME=HEADING1-1624></A>
<HR>
<H2>6.18.2  ToHex Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ToHex Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>ToHex<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The ToHex macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ToHex Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToHex<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>ToHex Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToHex<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>ToHex Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToHex<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-1632></A>
<HR>
<H2>6.18.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;1234&quot;,0
BadString       byte    &quot;EFGH&quot;,0
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                lesi    String2Convert
                toHex
                putw                     ;Prints 1234
                putcr
                 .
                 .
                 .
                try
                 .
                 .
                 .
                lesi    BadString
                toHex                   ;Raises an exception,
                putw                    ; does not print
                putcr                   ; anything here.
                 .
                 .
                 .
                exception $Conversion
                print   &quot;Conversion error occured&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
 The ToHex routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these ToHex calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard ToHex routine;  it expects a pointer to the string in ES:DI and returns the converted result in AX:<P>
<PRE>
                ToHex                    ;Generates a call to the stdlib $ToHex routine.

</PRE>
 The second version of the extended syntax ToHex call lets you specify a single parameter.  This must be the name of a byte variable.  ToHex assumes this is the name of a string variable that contains the value to convert.  It calls ToHexCS to do the conversion and returns the value in AX:<P>
<PRE>
                ToHex    String2Convert

; Equivalent to:

                ToHexCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where ToHex will put the result.  This particular form calls the ToHexStk routine:<P>
<PRE>
                ToHex    byteVar, wordVar
                ToHex    byteVar, [wordVar]
                ToHex    byteVar, [dwordVar]

                ToHex    [wordVar], wordVar
                ToHex    [wordVar], [wordVar]
                ToHex    [wordVar], [dwordVar]

                ToHex    [dwordVar], wordVar
                ToHex    [dwordVar], [wordVar]
                ToHex    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, ToHex assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then ToHex assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then ToHex assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a word variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  ToHex stores the converted integer in the word specified by this second parameter. <P>
 Note that ToHex converts all the calls above to ToHexStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls ToHexStk to do the work.<P>
<A NAME=HEADING1-1699></A>
<HR>
<H1>6.19  toInt, toIntStk, toIntCS, toIntTOS</H1>
 These routines are very similar to Atoi and AtoiStk.  There are three primary differences between the toInt* and the Atoi* routines:<P>
<PRE>
(1)	The Atoi* routines are sloppy.  They allow leading spaces and allow the number to end with any arbitrary non-digit character.  The toInt* routines are more rigorous in their checking.  In particular, the characters that appear in the string must be part of the number.  The conversion must end on a zero terminating byte, not an arbitrary character.

(2)	If exceptions are initialized and enabled, these routines generate a conversion exception when an error occurs.

(3)	There is no need for a toIntx routine because of point (1) above.  Leaving the ES:DI register pair pointing at the zero terminating byte would be of little use.
</PRE>
<A NAME=HEADING1-1706></A>
<HR>
<H2>6.19.1  Calling Conventions and Assertions</H2>
<PRE>
<B>toInt</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the signed result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.

<B>toIntStk</B>:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	AX contains the signed result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Pops pointer to string off the stack. Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToIntTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	ToIntTOS leaves the converted result on the top of the stack. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToIntCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	AX contains the signed result. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
</PRE>
 <P>
<A NAME=HEADING1-1735></A>
<HR>
<H2>6.19.2  ToInt Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ToInt Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>ToInt<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The ToInt macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ToInt Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToInt<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>ToInt Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToInt<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>ToInt Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToInt<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-1743></A>
<HR>
<H2>6.19.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;-12345&quot;,0
BadString       byte    &quot;ABCD&quot;,0
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                lesi    String2Convert
                toInt
                puti                    ;Prints -12345
                putcr
                 .
                 .
                 .
                try
                 .
                 .
                 .
                lesi    BadString
                toInt                   ;Raises an exception,
                puti                    ; does not print
                putcr                   ; anything here.
                 .
                 .
                 .
                exception $Conversion
                print   &quot;Conversion error occured&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
 The ToInt routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these ToInt calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard ToInt routine;  it expects a pointer to the string in ES:DI and returns the converted result in AX:<P>
<PRE>
                ToInt                    ;Generates a call to the stdlib $ToInt routine.

</PRE>
 The second version of the extended syntax ToInt call lets you specify a single parameter.  This must be the name of a byte variable.  ToInt assumes this is the name of a string variable that contains the value to convert.  It calls ToIntCS to do the conversion and returns the value in AX:<P>
<PRE>
                ToInt    String2Convert

; Equivalent to:

                ToIntCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where ToInt will put the result.  This particular form calls the ToIntStk routine:<P>
<PRE>
                ToInt    byteVar, wordVar
                ToInt    byteVar, [wordVar]
                ToInt    byteVar, [dwordVar]

                ToInt    [wordVar], wordVar
                ToInt    [wordVar], [wordVar]
                ToInt    [wordVar], [dwordVar]

                ToInt    [dwordVar], wordVar
                ToInt    [dwordVar], [wordVar]
                ToInt    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, ToInt assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then ToInt assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then ToInt assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a word variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  ToInt stores the converted integer in the word specified by this second parameter. <P>
 Note that ToInt converts all the calls above to ToIntStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls ToIntStk to do the work.<P>
<A NAME=HEADING1-1810></A>
<HR>
<H1>6.20  toLHex, toLHexStk, toLHexTOS, toLHexCS</H1>
 These routines are nearly identical to toHex and toHexStk except they convert hexadecimal strings to 32-bit values and return these values in EAX.<P>
<A NAME=HEADING1-1812></A>
<HR>
<H2>6.20.1  Calling Conventions and Assertions</H2>
<PRE>
<B>toLHex</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the hexadecimal result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.

<B>toLHexStk</B>:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	EAX contains the hexadecimal result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Pops pointer to string off the stack. Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToLHexTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	ToLongTOS leaves the converted result on the top of the stack. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToLHexCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	EAX contains the result. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the address of an ASCII representation of some number.
</PRE>
<A NAME=HEADING1-1840></A>
<HR>
<H2>6.20.2  ToLHex Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ToLHex Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>ToLHex<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The ToLHex macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ToLHex Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToLHex<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>ToLHex Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToLHex<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>ToLHex Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToLHex<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-1848></A>
<HR>
<H2>6.20.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;10000&quot;,0
BadString       byte    &quot;EFGH&quot;,0
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                lesi    String2Convert
                toLHex
                putul                     ;Prints 65536
                putcr
                 .
                 .
                 .
                try
                 .
                 .
                 .
                lesi    BadString
                toLHex                   ;Raises an exception,
                putul                    ; does not print
                putcr                   ; anything here.
                 .
                 .
                 .
                exception $Conversion
                print   &quot;Conversion error occured&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
 The ToLHex routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these ToLHex calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard ToLHex routine;  it expects a pointer to the string in ES:DI and returns the converted result in EAX:<P>
<PRE>
                ToLHex                    ;Generates a call to the stdlib $ToLHex routine.

</PRE>
 The second version of the extended syntax ToLHex call lets you specify a single parameter.  This must be the name of a byte variable.  ToLHex assumes this is the name of a string variable that contains the value to convert.  It calls ToLHexCS to do the conversion and returns the value in EAX:<P>
<PRE>
                ToLHex    String2Convert

; Equivalent to:

                ToLHexCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where ToLHex will put the result.  This particular form calls the ToLHexStk routine:<P>
<PRE>
                ToLHex    byteVar, wordVar
                ToLHex    byteVar, [wordVar]
                ToLHex    byteVar, [dwordVar]

                ToLHex    [wordVar], wordVar
                ToLHex    [wordVar], [wordVar]
                ToLHex    [wordVar], [dwordVar]

                ToLHex    [dwordVar], wordVar
                ToLHex    [dwordVar], [wordVar]
                ToLHex    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, ToLHex assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then ToLHex assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then ToLHex assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a dword variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  ToLHex stores the converted integer in the word specified by this second parameter. <P>
 Note that ToLHex converts all the calls above to ToLHexStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls ToLHexStk to do the work.<P>
<A NAME=HEADING1-1915></A>
<HR>
<H1>6.21  toLong, toLongStk, toLongTOS, toLongCS</H1>
 These routines are very similar to Atol and AtolStk.  There are three primary differences between the toLong* and the Atoi* routines:<P>
<PRE>
(1)	The Atol* routines are sloppy.  They allow leading spaces and allow the number to end with any arbitrary non-digit character.  The toLong* routines are more rigorous in their checking.  In particular, the characters that appear in the string must be part of the number.  The conversion must end on a zero terminating byte, not an arbitrary character.

(2)	If exceptions are initialized and enabled, these routines generate a conversion exception when an error occurs.

(3)	There is no need for a toLongx routine because of point (1) above.  Leaving the ES:DI register pair pointing at the zero terminating byte would be of little use.
</PRE>
<A NAME=HEADING1-1922></A>
<HR>
<H2>6.21.1  Calling Conventions and Assertions</H2>
<PRE>
<B>toLong</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the signed result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.

<B>toLongStk</B>:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	EAX contains the signed result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Pops pointer to string off the stack. Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToLongTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	ToLongTOS leaves the converted result on the top of the stack. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToLongCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	EAX contains the signed result. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the address of an ASCII representation of some number.
</PRE>
 <P>
<A NAME=HEADING1-1951></A>
<HR>
<H2>6.21.2  ToLong Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ToLong Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>ToLong<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The ToLong macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ToLong Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToLong<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>ToLong Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToLong<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>ToLong Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToLong<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-1959></A>
<HR>
<H2>6.21.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;-123456789&quot;,0
BadString       byte    &quot;ABCD&quot;,0
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                lesi    String2Convert
                toLong
                putl                    ;Prints -123456789
                putcr
                 .
                 .
                 .
                try
                 .
                 .
                 .
                lesi    BadString
                toLong                  ;Raises an exception,
                putl                    ; does not print
                putcr                   ; anything here.
                 .
                 .
                 .
                exception $Conversion
                print   &quot;Conversion error occured&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
 The ToLong routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these ToLong calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard ToLong routine;  it expects a pointer to the string in ES:DI and returns the converted result in EAX:<P>
<PRE>
                ToLong                    ;Generates a call to the stdlib $ToLong routine.

</PRE>
 The second version of the extended syntax ToLong call lets you specify a single parameter.  This must be the name of a byte variable.  ToLong assumes this is the name of a string variable that contains the value to convert.  It calls ToLongCS to do the conversion and returns the value in EAX:<P>
<PRE>
                ToLong    String2Convert

; Equivalent to:

                ToLongCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where ToLong will put the result.  This particular form calls the ToLongStk routine:<P>
<PRE>
                ToLong    byteVar, wordVar
                ToLong    byteVar, [wordVar]
                ToLong    byteVar, [dwordVar]

                ToLong    [wordVar], wordVar
                ToLong    [wordVar], [wordVar]
                ToLong    [wordVar], [dwordVar]

                ToLong    [dwordVar], wordVar
                ToLong    [dwordVar], [wordVar]
                ToLong    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, ToLong assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then ToLong assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then ToLong assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a dword variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  ToLong stores the converted integer in the word specified by this second parameter. <P>
 Note that ToLong converts all the calls above to ToLongStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls ToLongStk to do the work.<P>
<A NAME=HEADING1-2026></A>
<HR>
<H1>6.22  toULong, toULongStk</H1>
 These routines are very similar to Atoul and AtoulStk.  There are three primary differences between the toULong* and the Atoul* routines:<P>
<PRE>
(1)	The Atoul* routines are sloppy.  They allow leading spaces and allow the number to end with any arbitrary non-digit character.  The toULong* routines are more rigorous in their checking.  In particular, the characters that appear in the string must be part of the number.  The conversion must end on a zero terminating byte, not an arbitrary character.

(2)	If exceptions are initialized and enabled, these routines generate a conversion exception when an error occurs.

(3)	There is no need for a toULongx routine because of point (1) above.  Leaving the ES:DI register pair pointing at the zero terminating byte would be of little use.
</PRE>
<A NAME=HEADING1-2033></A>
<HR>
<H2>6.22.1  Calling Conventions and Assertions</H2>
<PRE>
<B>toULong</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.

<B>toULongStk</B>:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	EAX contains the unsigned result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Pops pointer to string off the stack. Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToULongTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	ToULongTOS leaves the converted result on the top of the stack. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToULongCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	EAX contains the result. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the address of an ASCII representation of some number.
</PRE>
<A NAME=HEADING1-2061></A>
<HR>
<H2>6.22.2  ToULong Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ToULong Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>ToULong<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 The ToULong macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ToULong Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToULong<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>ToULong Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToULong<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>ToULong Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToULong<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-2069></A>
<HR>
<H2>6.22.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;123456789&quot;,0
BadString       byte    &quot;ABCD&quot;,0
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                lesi    String2Convert
                toULong
                putul                    ;Prints 123456789
                putcr
                 .
                 .
                 .
                try
                 .
                 .
                 .
                lesi    BadString
                toULong                 ;Raises an exception,
                putul                   ; does not print
                putcr                   ; anything here.
                 .
                 .
                 .
                exception $Conversion
                print   &quot;Conversion error occured&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
 The ToULong routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these ToULong calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard ToULong routine;  it expects a pointer to the string in ES:DI and returns the converted result in EAX:<P>
<PRE>
                ToULong                    ;Generates a call to the stdlib $ToULong routine.

</PRE>
 The second version of the extended syntax ToULong call lets you specify a single parameter.  This must be the name of a byte variable.  ToULong assumes this is the name of a string variable that contains the value to convert.  It calls ToULongCS to do the conversion and returns the value in EAX:<P>
<PRE>
                ToULong    String2Convert

; Equivalent to:

                ToULongCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where ToULong will put the result.  This particular form calls the ToULongStk routine:<P>
<PRE>
                ToULong    byteVar, wordVar
                ToULong    byteVar, [wordVar]
                ToULong    byteVar, [dwordVar]

                ToULong    [wordVar], wordVar
                ToULong    [wordVar], [wordVar]
                ToULong    [wordVar], [dwordVar]

                ToULong    [dwordVar], wordVar
                ToULong    [dwordVar], [wordVar]
                ToULong    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, ToULong assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then ToULong assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then ToULong assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a dword variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  ToULong stores the converted integer in the word specified by this second parameter. <P>
 Note that ToULong converts all the calls above to ToULongStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls ToULongStk to do the work.<P>
<A NAME=HEADING1-2136></A>
<HR>
<H1>6.23  toUns, toUnsStk, toUnsTOS, toUnsCS</H1>
 These routines are very similar to Atou and AtouStk.  There are three primary differences between the toUnsigned* and the Atou* routines:<P>
<PRE>
(1)	The Atou* routines are sloppy.  They allow leading spaces and allow the number to end with any arbitrary non-digit character.  The toUns* routines are more rigorous in their checking.  In particular, the characters that appear in the string must be part of the number.  The conversion must end on a zero terminating byte, not an arbitrary character.

(2)	If exceptions are initialized and enabled, these routines generate a conversion exception when an error occurs.

(3)	There is no need for a toUnsx routine because of point (1) above.  Leaving the ES:DI register pair pointing at the zero terminating byte would be of little use.
</PRE>
<A NAME=HEADING1-2143></A>
<HR>
<H2>6.23.1  Calling Conventions and Assertions</H2>
<PRE>
<B>toUns</B>:
Inputs:	ES:DI points at the string to convert.
Outputs:	AX contains the unsigned result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	ES:DI points at a reasonable location containing the ASCII representation of some number.

<B>toUnsStk</B>:
Inputs:	A far pointer to the string to convert appears on the top of stack.
Outputs:	AX contains the unsigned result.  C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Pops pointer to string off the stack. Raises a $Conversion exception if there is a conversion error and exceptions are active.
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToUnsTOS</B>:
Inputs:	A far pointer to the string to convert (pushed first)  appears on the top of stack.
Outputs:	ToUnsTOS leaves the converted result on the top of the stack. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	Removes two bytes from the stack (result is two bytes, it replaces a four-byte pointer).
Assertions:	Far pointer points at a reasonable location containing the ASCII representation of some number.

<B>ToUnsCS</B>:
Inputs:	A dword pointer immediately following the call in the code stream contains a pointer to the string to convert.
Outputs:	AX contains the signed result. C=1 if there was a conversion error and exceptions are not active.
Errors:	None.
Side Effects:	None.
Assertions:	The return address points at a reasonable location containing the ASCII representation of some number.
</PRE>
 <P>
<A NAME=HEADING1-2172></A>
<HR>
<H2>6.23.2  ToUns Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ToUns Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>ToUns<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The ToUns macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ToUns Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToUns<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>ToUns Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToUns<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>ToUns Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ToUns<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-2180></A>
<HR>
<H2>6.23.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    &quot;12345&quot;,0
BadString       byte    &quot;ABCD&quot;,0
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                lesi    String2Convert
                toUns
                putu                    ;Prints 12345
                putcr
                 .
                 .
                 .
                try
                 .
                 .
                 .
                lesi    BadString
                toUns                   ;Raises an exception,
                putu                    ; does not print
                putcr                   ; anything here.
                 .
                 .
                 .
                exception $Conversion
                print   &quot;Conversion error occured&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
 The ToUns routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these ToUns calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard ToUns routine;  it expects a pointer to the string in ES:DI and returns the converted result in AX:<P>
<PRE>
                ToUns                    ;Generates a call to the stdlib $ToUns routine.

</PRE>
 The second version of the extended syntax ToUns call lets you specify a single parameter.  This must be the name of a byte variable.  ToUns assumes this is the name of a string variable that contains the value to convert.  It calls ToUnsCS to do the conversion and returns the value in AX:<P>
<PRE>
                ToUns    String2Convert

; Equivalent to:

                ToUnsCS
                dword   String2Convert

</PRE>
 The third extended syntax form allows two parameters.  The first specifies the address of the string to convert, the second specifies the address where ToUns will put the result.  This particular form calls the ToUnsStk routine:<P>
<PRE>
                ToUns    byteVar, wordVar
                ToUns    byteVar, [wordVar]
                ToUns    byteVar, [dwordVar]

                ToUns    [wordVar], wordVar
                ToUns    [wordVar], [wordVar]
                ToUns    [wordVar], [dwordVar]

                ToUns    [dwordVar], wordVar
                ToUns    [dwordVar], [wordVar]
                ToUns    [dwordVar], [dwordVar]

</PRE>
 If the first parameter is a byte variable, ToUns assumes that it's the name of a string variable.  It converts that string to an integer.  If the first parameter is of the form &quot;[wordVar]&quot; then ToUns assumes that the word variable is a near pointer to a string.  It converts the string pointed at by DS:[wordVar] to an integer.  If the first parameter is &quot;[dwordVar]&quot; then ToUns assumes this is a dword variable containing a far pointer to the string, it converts that string to an integer.<P>
 The second parameter must be a word variable, a near pointer (&quot;[wordVar]&quot;), or a far pointer (&quot;[dwordVar]&quot;).  ToUns stores the converted integer in the word specified by this second parameter. <P>
 Note that ToUns converts all the calls above to ToUnsStk.  It pushes a 32-bit address of the string onto the stack followed by the 32-bit address of the second operand.  It then calls ToUnsStk to do the work.<P>
<A NAME=HEADING1-2247></A>
<HR>
<H1>6.24  UlSize, UlSizeCS, UlSizeStk, UlSizeTOS</H1>
 These routines determine the number of print positions a 32-bit unsigned integer will require on output.  <P>
<A NAME=HEADING1-2249></A>
<HR>
<H2>6.24.1  Calling Conventions and Assertions</H2>
<PRE>
<B>UlSize</B>:
Inputs:	EAX contains the integer value test.
Outputs:	UlSize returns the number of print positions in EAX.
Errors:	None.
Side Effects:	None.

<B>UlSizeCS</B>:
Inputs:	A far pointer to a 32-bit unsigned integer value immediately follows the call in the code stream.
Outputs:	UlSizeCS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	On return, UlSizeCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.

<B>UlSizeTOS</B>:
Inputs:	The TOS contains the unsigned 32-bit value to test.
Outputs:	UlSizeTOS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

<B>UlSizeSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 32-bit value in memory to test.
Outputs:	UlSizeStk returns the size of the integer in the EAX register.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

</PRE>
<A NAME=HEADING1-2274></A>
<HR>
<H2>6.24.2  UlSize Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>UlSize Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>UlSize<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 The UlSize macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>UlSize Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>UlSize<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-2280></A>
<HR>
<H2>6.24.3  Syntax &amp; Examples</H2>
 The following example demonstrates how to create left and right justified versions of an integer value for possible output:<P>
<PRE>
Value           dword   123456
ValPtr1         word    Value
ValPtr2         dword   Value
                 .
                 .
                 .

; Output an integer right justified in a field of 12 print positions
; (This is, essentially, how PutUlSize works).

                mov     eax, Value
                UlSize
                add     ax, -12         ;Compute UlSize(value) - 12.
                neg     ax              ;Compute 12-UlSize(value).
                call    PrtSpcs
                putl    Value
                 .
                 .
                 .

; Output an integer left justified in a field of 12 print positions.

                mov     eax, Value
                putl
                UlSize
                add     ax, -12         ;Compute UlSize(value) - 12.
                neg     ax              ;Compute 12-UlSize(value).
                call    PrtSpcs

</PRE>
 The UlSize macro also supports an extended syntax.  Without any parameters, UlSize simply calls the StdLib $UlSize procedure.  With a word parameter, UlSize calls the StdLib $UlSizeCS procedure.  With a word pointer or dword pointer argument, UlSize calls the StdLib $UlSizeStk routine.<P>
<PRE>
                UlSize                   ;Calls $UlSize
                
;The following are equivalent:

                UlSize   Value
                
                UlSizeCS
                dword   Value
                
;The following are equivalent:

                UlSize   [ValPtr1]
                
                push    ds
                push    ValPtr1
                UlSizeStk
                
;The following are equivalent:

                UlSize   [ValPtr2]
                
                pushd   ValPtr2
                UlSizeStk
                  .
                  .
                  .
prtspcs         proc    near
                push    eax
                mov     cx, ax
                mov     al, ' '
                jcxz    psDone
PrtLp:          putc
                loop    PrtLp
psDone:         pop     eax
                ret
prtspcs         endp
</PRE>
<A NAME=HEADING1-2348></A>
<HR>
<H1>6.25  Ultoa, UltoaCS, UltoaStk, UltoaTOS, Ultoax, Ultoam</H1>
 These routines convert a 32-bit unsigned integer value to a string of decimal characters (plus a zero terminating byte).  These routines supress any leading zeros unless, of course, the integer value is zero.<P>
<A NAME=HEADING1-2350></A>
<HR>
<H2>6.25.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Ultoa</B>:
Inputs:	EAX contains the integer value to convert. ES:DI points at a string that can hold at least 11 bytes (up to ten digits and a zero terminating character).
Outputs:	Ultoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at an array that can hold at least 12 bytes.

<B>Ultoam</B>:
Inputs:	EAX contains the integer value to convert.
Outputs:	Ultoa stores the converted string onto the heap.  It returns a pointer to the string in the ES:DI register pair.
Errors:	The malloc routine raises an exception if there is insufficient room on the heap.
Side Effects:	None.
Assertions:	Sufficient memory is available on the heap.

<B>Ultoax</B>:
Inputs:	EAX contains the integer value to convert. ES:DI points at a string that can hold at least 11 bytes ten digits and a zero terminating byte).
Outputs:	Ultoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	Does not preserve DI.  This routine leaves DI pointing at the zero byte at the end of the converted string.
Assertions:	ES:DI points at an array that can hold at least 11 bytes.

<B>UltoaCS</B>:
Inputs:	EAX contains the 32-bit unsigned integer value to convert. A far pointer to a string buffer that will hold the result immediately follows the call in the code stream.
Outputs:	UltoaCS stores the converted string at the location pointed by the far pointer in the code stream.
Errors:	None.
Side Effects:	On return, UltoaCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.
Assertions:	The far pointer in the code stream points at an array that can hold at least 11 bytes.

<B>UltoaTOS</B>:
Inputs:	The TOS contains a 32-bit unsigned integer.  UltoaTOS converts this 32-bit value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  UltoaTOS stores the converted string at this address.
Outputs:	UltoaTOS stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the value and far pointer off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least 11 bytes.

<B>UltoaSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 32-bit unsigned integer value in memory. UltoaStk converts this value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  UltoaStk stores the converted string at this address.
Outputs:	UltoaStk stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the two far pointers off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least 11 bytes.

</PRE>
<A NAME=HEADING1-2393></A>
<HR>
<H2>6.25.2  Ultoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Ultoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Ultoa<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 The Ultoa macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Ultoa Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Ultoa<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Ultoa Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>word var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Ultoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Ultoa Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Ultoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-2402></A>
<HR>
<H2>6.25.3  Syntax &amp; Examples</H2>
<PRE>
ConvertedStr    byte    32 dup (0)
Value           dword   123456789
Value2          dword   987654321
wPtr            word    Value
dPtr            dword   Value2
sptr            dword   ConvertedStr
                 .
                 .
                 .
                mov     eax, Value
                lesi    ConvertedStr
                Ultoa
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     eax, Value2
                Ultoam
                print   &quot;ConvertedStr=&quot;
                puts
                free
                putcr
                 .
                 .
                 .
                mov     eax, Value
                lesi    ConvertedStr
                Ultoax
                mov     byte ptr es:[di], ' '
                mov     eax, Value2
                Ultoax
                printf  &quot;Value &amp; value2 = %s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     eax, Value
                UltoaCS
                dword   ConvertedStr
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                push    Value
                UltoaTOS
                printf  &quot;Value=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                pshadrs Value2
                UltoaStk
                printf  &quot;Value2=%s\n&quot;, ConvertedStr


</PRE>
 The Ultoa routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Ultoa calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Ultoa routine;  it expects a pointer to the string in ES:DI and the value to convert in EAX:<P>
<PRE>
                Ultoa   ;Generates a call to the stdlib $Ultoa routine.

</PRE>
 The second version of the extended syntax Ultoa call lets you specify a single string parameter (the value to convert is assumed to be in the EAX register).  If this is the name of a byte variable,  Ultoa assumes this is the name of a string variable where it stores the converted string..  It calls UltoaCS to do the conversion:<P>
<PRE>
                Ultoa    ConvertedStr

; Equivalent to:

                UltoaCS
                dword   ConvertedStr
</PRE>
 If this is a [wvar] or [dwvar] operand (word pointer or double word pointer), then Ultoa assumes the specified variable is a pointer to the array that will hold the string.  In either case ([wordvar] or [dwordvar]) the macro pushes the far address onto the stack along with the value to convert and calls the UltoaTOS routine to do the conversion.<P>
 The third extended syntax form allows two parameters.  The first specifies the value to convert, the second specifies the address where Ultoa will store the converted string.  This particular form calls the UltoaStk routine:<P>
<PRE>
;                        Value     string
;                        -------- ------------
                ultoa    byteVar, byteVar
                ultoa    byteVar, [wordVar]
                ultoa    byteVar, [dwordVar]

                ultoa    [wordVar], wordVar
                ultoa    [wordVar], [wordVar]
                ultoa    [wordVar], [dwordVar]

                ultoa    [dwordVar], wordVar
                ultoa    [dwordVar], [wordVar]
                ultoa    [dwordVar], [dwordVar]

</PRE>
 The first parameter must be a word variable or a pointer to a word variable.  The second parameter must be a pointer to an array that has enough storage to hold 11 characters (ten digits and a zero terminating byte).<P>
<A NAME=HEADING1-2486></A>
<HR>
<H1>6.26  USize, USizeCS, USizeStk, USizeTOS</H1>
 These routines determine the number of print positions a 16-bit integer unsigned will require on output.  <P>
<A NAME=HEADING1-2488></A>
<HR>
<H2>6.26.1  Calling Conventions and Assertions</H2>
<PRE>
<B>USize</B>:
Inputs:	AX contains the unsigned integer value test.
Outputs:	USize returns the number of print positions in EAX (1-5).
Errors:	None.
Side Effects:	None.

<B>USizeCS</B>:
Inputs:	A far pointer to a 16-bit unsigned integer value immediately follows the call in the code stream.
Outputs:	USizeCS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	On return, USizeCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.

<B>USizeTOS</B>:
Inputs:	The TOS contains the unsigned 16-bit value to test.
Outputs:	USizeTOS returns the size of the integer in EAX.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

<B>USizeSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 16-bit value in memory to test.
Outputs:	USizeStk returns the size of the integer in the EAX register.
Errors:	None.
Side Effects:	Pops the far pointer off the stack upon return.

</PRE>
<A NAME=HEADING1-2513></A>
<HR>
<H2>6.26.2  USize Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>USize Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>USize<TD>X<TD>X<TD>X<TD>X<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 The USize macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>USize Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>USize<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-2519></A>
<HR>
<H2>6.26.3  Syntax &amp; Examples</H2>
 The following example demonstrates how to create left and right justified versions of an integer value for possible output:<P>
<PRE>
Value           word    12345
ValPtr1         word    Value
ValPtr2         dword   Value
                 .
                 .
                 .

; Output an integer right justified in a field of 12 print positions
; (This is, essentially, how PutUSize works).

                mov     ax, Value
                USize
                add     ax, -12         ;Compute USize(value) - 12.
                neg     ax              ;Compute 12-USize(value).
                call    PrtSpcs
                puti    Value
                 .
                 .
                 .

; Output an integer left justified in a field of 12 print positions.

                mov     ax, Value
                puti
                USize
                add     ax, -12         ;Compute USize(value) - 12.
                neg     ax              ;Compute 12-USize(value).
                call    PrtSpcs

</PRE>
 The USize macro also supports an extended syntax.  Without any parameters, USize simply calls the StdLib $USize procedure.  With a word parameter, USize calls the StdLib $USizeCS procedure.  With a word pointer or dword pointer argument, USize calls the StdLib $USizeStk routine.<P>
<PRE>
                USize                   ;Calls $USize
                
;The following are equivalent:

                USize   Value
                
                USizeCS
                dword   Value
                
;The following are equivalent:

                USize   [ValPtr1]
                
                push    ds
                push    ValPtr1
                USizeStk
                
;The following are equivalent:

                USize   [ValPtr2]
                
                pushd   ValPtr2
                USizeStk
                  .
                  .
                  .
prtspcs         proc    near
                push    eax
                mov     cx, ax
                mov     al, ' '
                jcxz    psDone
PrtLp:          putc
                loop    PrtLp
psDone:         pop     eax
                ret
prtspcs         endp

</PRE>
<A NAME=HEADING1-2588></A>
<HR>
<H1>6.27  Utoa, UtoaCS, UtoaStk, UtoaTOS, Utoax, Utoam</H1>
 These routines convert a 16-bit unsigned integer value to a string of decimal characters (plus a zero terminating byte).  These routines supress any leading zeros unless, of course, the integer value is zero.<P>
<A NAME=HEADING1-2590></A>
<HR>
<H2>6.27.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Utoa</B>:
Inputs:	AX contains the unsigned integer value to convert. ES:DI points at a string that can hold at least six bytes (up to five digits, and a zero terminating character).
Outputs:	Utoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at an array that can hold at least six bytes.

<B>Utoam</B>:
Inputs:	AX contains the unsigned integer value to convert.
Outputs:	Utoa stores the converted string onto the heap.  It returns a pointer to the string in the ES:DI register pair.
Errors:	The malloc routine raises an exception if there is insufficient room on the heap.
Side Effects:	None.
Assertions:	Sufficient memory is available on the heap.

<B>Utoax</B>:
Inputs:	AX contains the unsigned integer value to convert. ES:DI points at a string that can hold at least six bytes (five digits and a zero terminating byte).
Outputs:	Utoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	Does not preserve DI.  This routine leaves DI pointing at the zero byte at the end of the converted string.
Assertions:	ES:DI points at an array that can hold at least six bytes.

<B>UtoaCS</B>:
Inputs:	AX contains the 16-bit unsigned integer value to convert. A far pointer to a string buffer that will hold the result immediately follows the call in the code stream.
Outputs:	UtoaCS stores the converted string at the location pointed by the far pointer in the code stream.
Errors:	None.
Side Effects:	On return, UtoaCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.
Assertions:	The far pointer in the code stream points at an array that can hold at least six bytes.

<B>UtoaTOS</B>:
Inputs:	The TOS contains au unsigned 16-bit value.  UtoaTOS converts this 16-bit value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  UtoaTOS stores the converted string at this address.
Outputs:	UtoaTOS stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the value and far pointer off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least six bytes.

<B>UtoaSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 16-bit value in memory.  UtoaStk converts this value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  UtoaStk stores the converted string at this address.
Outputs:	UtoaStk stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the two far pointers off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least six bytes.

</PRE>
<A NAME=HEADING1-2633></A>
<HR>
<H2>6.27.2  Utoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Utoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Utoa<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 The Utoa macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Utoa Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>word Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Utoa<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Utoa Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>word var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Utoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Utoa Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Utoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-2642></A>
<HR>
<H2>6.27.3  Syntax &amp; Examples</H2>
<PRE>
ConvertedStr    byte    32 dup (0)
Value           word    12345
Value2          word    4321
wPtr            word    Value
dPtr            dword   Value2
sptr            dword   ConvertedStr
                 .
                 .
                 .
                mov     ax, Value
                lesi    ConvertedStr
                Utoa
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     ax, Value2
                Utoam
                print   &quot;ConvertedStr=&quot;
                puts
                free
                putcr
                 .
                 .
                 .
                mov     ax, Value
                lesi    ConvertedStr
                Utoax
                mov     byte ptr es:[di], ' '
                mov     ax, Value2
                Utoax
                printf  &quot;Value &amp; value2 = %s\n&quot;, ConvertedStr
                 .
                 .
                 .
                mov     ax, Value
                UtoaCS
                dword   ConvertedStr
                printf  &quot;ConvertedStr=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                push    Value
                UtoaTOS
                printf  &quot;Value=%s\n&quot;, ConvertedStr
                 .
                 .
                 .
                pshadrs ConvertedStr
                pshadrs Value2
                UtoaStk
                printf  &quot;Value2=%s\n&quot;, ConvertedStr


</PRE>
 The Utoa routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Utoa calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Utoa routine;  it expects a pointer to the string in ES:DI and the value to convert in AX:<P>
<PRE>
                Utoa   ;Generates a call to the stdlib $Utoa routine.

</PRE>
 The second version of the extended syntax Utoa call lets you specify a single string parameter (the value to convert is assumed to be in the AX register).  If this is the name of a byte variable,  Utoa assumes this is the name of a string variable where it stores the converted string..  It calls UtoaCS to do the conversion:<P>
<PRE>
                Utoa    ConvertedStr

; Equivalent to:

                UtoaCS
                dword   ConvertedStr
</PRE>
 If this is a [wvar] or [dwvar] operand (word pointer or double word pointer), then Utoa assumes the specified variable is a pointer to the array that will hold the string.  In either case ([wordvar] or [dwordvar]) the macro pushes the far address onto the stack along with the value to convert and calls the UtoaTOS routine to do the conversion.<P>
 The third extended syntax form allows two parameters.  The first specifies the value to convert, the second specifies the address where Utoa will store the converted string.  This particular form calls the UtoaStk routine:<P>
<PRE>
;                       Value     string
;                       -------- ------------
                Utoa    byteVar, byteVar
                Utoa    byteVar, [wordVar]
                Utoa    byteVar, [dwordVar]

                Utoa    [wordVar], wordVar
                Utoa    [wordVar], [wordVar]
                Utoa    [wordVar], [dwordVar]

                Utoa    [dwordVar], wordVar
                Utoa    [dwordVar], [wordVar]
                Utoa    [dwordVar], [dwordVar]

</PRE>
 The first parameter must be a word variable or a pointer to a word variable.  The second parameter must be a pointer to an array that has enough storage to hold six characters (five digits and a zero terminating byte).<P>
<A NAME=HEADING1-2726></A>
<HR>
<H1>6.28  Wtoa, WtoaCS, WtoaStk, WtoaTOS, Wtoax, Wtoam</H1>
 These routines convert a 16-bit integer value to a string containing exactly four characters (plus a zero terminating byte).  The string is the hexadecimal representation of the unsigned integer value.  These routines print any necessary leading zeros;  the string is always exactly four characters long.<P>
<A NAME=HEADING1-2728></A>
<HR>
<H2>6.28.1  Calling Conventions and Assertions</H2>
<PRE>
<B>Wtoa</B>:
Inputs:	AX contains the integer value to convert. ES:DI points at a string that can hold at least three bytes (two digits plus a zero terminating character).
Outputs:	Wtoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	None.
Assertions:	ES:DI points at an array that can hold at least five bytes.

<B>Wtoam</B>:
Inputs:	AX contains the integer value to convert.
Outputs:	Wtoa stores the converted string onto the heap.  It returns a pointer to the string in the ES:DI register pair.
Errors:	The malloc routine raises an exception if there is insufficient room on the heap..
Side Effects:	None.
Assertions:	Sufficient memory is available on the heap.

<B>Wtoax</B>:
Inputs:	AX contains the integer value to convert. ES:DI points at a string that can hold at least five bytes (four digits plus a zero terminating character).
Outputs:	Wtoa stores the converted string at the location pointed by ES:DI.
Errors:	None.
Side Effects:	Does not preserve DI.  This routine leaves DI pointing at the zero byte at the end of the converted string.
Assertions:	ES:DI points at an array that can hold at least five bytes.

<B>WtoaCS</B>:
Inputs:	AX contains the 16-bit integer value to convert. A far pointer to a string buffer that will hold the result immediate follows the call in the code stream.
Outputs:	WtoaCS stores the converted string at the location pointed by the far pointer in the code stream.
Errors:	None.
Side Effects:	On return, WtoaCS modifies the return address so that the return operation skips over the far pointer following the call in the code stream.
Assertions:	The far pointer in the code stream points at an array that can hold at least five bytes.

<B>WtoaTOS</B>:
Inputs:	The TOS contains a 16-bit value.  WtoaTOS converts this 16-bit value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  WtoaTOS stores the converted string at this address.
Outputs:	WtoaTOS stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the value and far pointer off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least five bytes.

<B>WtoaSTK</B>:
Inputs:	The TOS contains a 32-bit far pointer that points at a 16-bit value in memory.  WtoaStk converts this value to a string.  NOS (next on stack, just above the TOS value) is a 32-bit far pointer.  WtoaStk stores the converted string at this address.
Outputs:	WtoaStk stores the converted string at the location pointed by the far pointer on NOS.
Errors:	None.
Side Effects:	Pops the two far pointers off the stack upon return.
Assertions:	The far pointer on NOS points at an array that can hold at least five bytes.

</PRE>
<A NAME=HEADING1-2771></A>
<HR>
<H2>6.28.2  Wtoa Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Wtoa Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>m<TR>
<TD>Wtoa<TD>X<TD>X<TD>X<TD>X<TD>X<TD>-<TD>X</TABLE>
<P>
 <P>
 The Wtoa macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Wtoa Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>Plain<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Wtoa<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
 
<TABLE BORDER="1">
<CAPTION>Wtoa Two-Operand Syntax (First Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Wtoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 
<TABLE BORDER="1">
<CAPTION>Wtoa Two-Operand Syntax (Second Operand)</CAPTION>
<TH>Name<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Wtoa<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
 <P>
<A NAME=HEADING1-2780></A>
<HR>
<H2>6.28.3  Syntax &amp; Examples</H2>
<PRE>
String2Convert  byte    32 dup (0)
Value           word    0ABCDh
Value2          word    4567h
wPtr            word    Value
dPtr            dword   Value2

                mov     ax, Value
                lesi    String2Convert
                Wtoax
                mov     byte ptr es:[di], ' '
                mov     ax, Value2
                Wtoa
                printf  &quot;Str2Cnvrt=%s\n&quot;, String2Convert
                 .
                 .
                 .
                mov     ax, Value
                WtoaCS
                dword   String2Convert
                printf  &quot;Str2Cnvrt=%s\n&quot;, String2Convert
                 .
                 .
                 .
                pshadrs String2Convert
                push    word ptr Value2
                WtoaStk
                printf  &quot;String2Convert=%s\n&quot;, String2Convert
                 .
                 .
                 .
                pshadrs String2Convert
                push    word ptr Value
                WtoaTOS
                printf  &quot;String2Convert=%s\n&quot;, String2Convert

</PRE>
 The Wtoa routines also allow the extended syntax using the stdlib &quot;addressing modes.&quot;  There are three basic forms for these Wtoa calls: &quot;plain&quot; without any parameters, a single parameter version, and several two-parameter versions.<P>
 The plain version (without any parameters) simply calls the standard Wtoa routine;  it expects a pointer to the string in ES:DI and the value to convert in AX:<P>
<PRE>
                Wtoa   ;Generates a call to the stdlib $Wtoa routine.

</PRE>
 The second version of the extended syntax Wtoa call lets you specify a single string parameter (the value to convert is assumed to be in the AX register).  If this is the name of a byte variable,  Wtoa assumes this is the name of a string variable where it stores the converted string..  It calls WtoaCS to do the conversion:<P>
<PRE>
                Wtoa    String2Convert

; Equivalent to:

                WtoaCS
                dword   String2Convert
</PRE>
 If this is a [wvar] or [dwvar] operand (word pointer or double word pointer), then Wtoa assumes the specified variable is a pointer to the array that will hold the string.  In either case ([wordvar] or [dwordvar]) the macro pushes the far address onto the stack along with the value to convert and calls the WtoaTOS routine to do the conversion.<P>
 The third extended syntax form allows two parameters.  The first specifies the value to convert, the second specifies the address where htot will store the converted string.  This particular form calls the WtoaStk routine:<P>
<PRE>
;                       Value     string
;                       -------- ------------
                Wtoa    byteVar, byteVar
                Wtoa    byteVar, [wordVar]
                Wtoa    byteVar, [dwordVar]

                Wtoa    [wordVar], wordVar
                Wtoa    [wordVar], [wordVar]
                Wtoa    [wordVar], [dwordVar]

                Wtoa    [dwordVar], wordVar
                Wtoa    [dwordVar], [wordVar]
                Wtoa    [dwordVar], [dwordVar]

</PRE>
 The first parameter must be a byte variable or a pointer to a byte variable.  The second parameter must be a pointer to an array that has enough storage to hold five characters (four digits and a zero terminating byte).<P>
</BODY>
</HTML> 