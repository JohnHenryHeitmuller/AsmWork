<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE> </TITLE>
</HEAD>
<BODY>
<A NAME=HEADING1></A>
Stdlib Exception Handling<P>
<HR>
<!-- TOC --><DL>
<DT><A HREF="except_1.htm#HEADING1-1"><B></B>Exception Handling Routines</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-3"><B>8.1	</B> - Interface</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-11"><B>8.2	</B> - Overview of Exception Handling</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-145"><B>8.3	</B> - Standard Exception Constants</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-150"><B>8.4	</B> - Try, EndTry</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-154"><B>8.4.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-155"><B>8.4.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-177"><B>8.5	</B> - InitExcept, InitEx24, CleanUpEx</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-181"><B>8.5.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-182"><B>8.5.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-205"><B>8.5.3	</B> - Alternate Syntax</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-229"><B>8.6	</B> - EnableExcept, DisableExcept, GetXEnabled</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-235"><B>8.6.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-236"><B>8.6.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-284"><B>8.7	</B> - Raise</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-288"><B>8.7.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-289"><B>8.7.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-337"><B>8.7.3	</B> - Alternate Syntax</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-345"><B>8.8	</B> - PassExcept</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-349"><B>8.8.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-350"><B>8.8.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-392"><B>8.8.3	</B> - Alternate Syntax</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-400"><B>8.9	</B> - Exception</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-412"><B>8.9.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-413"><B>8.9.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-459"><B>8.9.3	</B> - Alternate Syntax</A>
<DD>
<DT><A HREF="except_1.htm#HEADING1-461"><B>8.10	</B> - Critical Error Exceptions</A>
<DD>
<DT><A HREF="except_2.htm#HEADING2-0"><B></B></A>
<DD>
</DL>

<A NAME=HEADING1-0></A>
<H1></H1>
<HR>
<A NAME=HEADING1-1></A>
<H1> Exception Handling Routines</H1>
 The UCR Standard Library (stdlib) contains a large number of routines that convert data from one format to another.   These routines typically convert between some binary format and ASCII.  For example, the ATOI routine converts an ASCII string to an integer.  Conversely, the ITOA routine converts an integer value to an ASCII string.  There are other conversions as well.  For example, the TOUPPER routine converts lower case characters to upper case.<P>
<A NAME=HEADING1-3></A>
<HR>
<H2>8.1  Interface</H2>
 To access the routines in the exceptions package, your assembly language module must include the file &quot;excepts.a&quot; during assembly.  You can accomplish this with either of the following include statements in your assembly code:<P>
<PRE>
	include	excepts.a
or
	include	ucrlib.a

</PRE>
 The excepts.a include file exports several symbols.  The UCR Standard Library prefaces all &quot;private&quot; names with a dollar sign (&quot;$&quot;).  You should not call any routine in this package that begins with this symbol unless otherwise advised.  To avoid name conflicts, you should not define any symbols in your programs that begin with a dollar sign (&quot;$&quot;).  Note that future versions of the stdlib (that remain compatible with this release)  may change &quot;private&quot; names.  To remain compatible with future releases, you must not refer to these &quot;private&quot; names within your programs.<P>
 Source code appearing in this chapter is current as of Version Two, Release 40.   There may be minor changes between this source code and the current release.<P>
<A NAME=HEADING1-11></A>
<HR>
<H2>8.2  Overview of Exception Handling</H2>
 The UCR Standard Library uses a high level language syntax to handle exceptions, much like that used by C++ and Delphi.  The basic idea is that you protect blocks of statements with a TRY..ENDTRY block.  Within the try..endtry block you can specify a generic exception handler for any exception that comes along or you can specify specific exceptions to handle.<P>
 The Standard Library supports many different exceptions.  Because this list is changing rapidly, you should consult the &quot;excepts.a&quot; file.  This file enumerates all the possible exceptions.   Examples of exceptions the stdlib package does support include:<P>
 The standard supported list of hardware exceptions include the INT 00 (divide errors), INT 04 (overflow), INT 05 (bounds violation), and INT 06 (invalid opcode).  Many of the standard library routines have an optional version that raise exceptions on various errors.  Finally, you can define your own exceptions and raise them if an error occurs.<P>
 To use the exception handling package you must call the InitExcept routine to initialize the package.  This patches the system's interrupt vectors for hardware trap support and sets up other internal variables the exception handling package uses.  After calling InitExcept you can use TRY..ENDTRY blocks to capture exceptions in  your program.  After you are through processing exceptions, and certainly before your program terminates, you must call CleanUpEx to restore the system's interrupt vector table (failure to do so may crash the system after your program terminates.<P>
 To protect a sequence of statements you use the TRY..EXCEPTION..ENDTRY statements.  A typical try..endtry block takes the following form:<P>
<PRE>
                InitExcept
                 .
                 .
                 .
                try
                 .
                 .
                 .
        &lt;Code that may generate an exception&gt;
                 .
                 .
                 .
                Exception $Break        ;Handle Control-C exception
                print     &quot;You Pressed control-C&quot;,nl
                
                Exception $InsuffMem
                print     &quot;MALLOC error occured- insufficient memory&quot;,nl
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
        &lt;Code that is not protected by the above try..endtry block&gt;
                 .
                 .
                 .
                CleanUpEx

</PRE>
 This code begins by calling the stdlib InitExcept routine.  You must always call InitExcept before attempting to use try..endtry blocks in your program.  If you do not do this, the exceptions package will only be able to handle user software generated exceptions;  it will not be able to process exceptions normally supported by the stdlib package. After calling InitExcept the stdlib package will properly process exceptions within a try..endtry block.<P>
 The InitExcept routine installs a default exception handler.  Therefore, if an exception occurs outside a try..endtry block, the default exception handler will execute.  This default exception handler print &quot;Unclaimed Exception&quot; along with the exception number and then aborts the program.  You should handle all exceptions within your program.  As a general rule, if the default handler executes then you are not using the exceptions package properly.<P>
 Immediately following the try block are the statements you want to protect if an exception occurs.  After executing the try statement, your program executes the block of statements immediately following try up to the first &quot;exception&quot; or &quot;endtry&quot; statement.  If an exception does not occur while executing this &quot;try block,&quot; then program control transfers to the first statement following the endtry statement.  Note that your program will skip all the exception blocks if an exception does not occur.<P>
 If an exception occurs during the execution of the try block, then the program loads the AX register with an exception number and jumps to the first exception statement in the try..endtry block.  As a general rule the exception statements will have a single parameter specifying the exception number for that particular handler.  The exception statement will compare the value in AX against the exception statement's parameter.  If they match, then the program will execute that particular exception handler.  If they do not match, the try..endtry block will seek the next exception statement (in that try..endtry block) and compare AX against it's exception number.  <P>
 The try..endtry block repeats this operation until it matches an exception statement, it encounters an exception statement without an exception constant, or it encounters the endtry statement.  An exception statement without a corresponding exception constant, if present, must be the last exception handler in a try..endtry block.  That is, there must not be any additional exception statements before the corresponding endtry.  This is the default  exception handler.  If none of the previous exception handlers took care of the exception, the try..endtry block executes the default handler.  The default handler can determine the source of the exception via the exception number in the AX register.<P>
 If, while seeking an appropriate exception handler, the try..endtry block hits the endtry statement, the stdlib exception handling package transfers control to an enclosing try..endtry block and searches through its exception list.  This continues until the system finds an appropriate handler or it encounters the system default exception handler.<P>
 Consider the previous example.  In the code protected by the try..endtry block there are two exception handlers:  one that handles the $Break (control-C) event and one that handles an out of memory event ($InsuffMem).  Suppose a overflow exception ($Overflow) occurs.  Since this try..endtry block does not provide a default exception handler, it would pass control to an enclosing try..endtry block.  There is always at least one enclosing try..endtry block- the default exception handler that stdlib provides.<P>
 Consider the following example.  This code asks the user to input an integer value.  It calls gets to read a line from the user and then stoi (string to integer) to convert this text to a numeric value.  Stoi raises a conversion exception if the string is not a proper integer value.  The try..endtry block catches this exception, tells the user to reenter the value, and sets up the loop control variable to force a repeat of the input operation.<P>
 This code also adds 1000 to the value the user inputs and then checks for signed integer overflow via the INTO instruction.  Note, however, that the try..endtry block enclosing the INTO instruction does not handle the $Overflow exception.  Therefore, should overflow occur the innermost try..endtry block transfers control to the enclosing try..endtry block to handle the overflow exception.  Should any other exception occur, the system default exception handler would handle the exception.<P>
<PRE>
                InitExcept
                 .
                 .
                 .
                try
                
NumInLoop:      print   &quot;Enter an integer value:&quot;
                mov     GoodInput, 1

                try
                
                lesi    InputLine
                gets
                stoi
                add     ax, 1000
                into
                
                Exception $Conversion
                print     nl,&quot;Illegal value, please reenter&quot;,nl
                mov     GoodInput,0
                
                endtry
                
                cmp     GoodInput, 1
                jne     NumInLoop
                
                
                Exception $Overflow
                print     &quot;The number was too large, using default value&quot;,nl
                mov     ax, 1000
                
                endtry
                 .
                 .
                 .
        &lt;Code that is not protected by the above try..endtry block&gt;
                 .
                 .
                 .
                CleanUpEx

</PRE>
 Note that try..endtry nesting is dynamic, not lexical.  That is, the try..endtry blocks do not need to be physically nested in your source code.  Instead, execution of a second try statement before executing the endtry associated with the first try causes the nesting to occur.  The following code sequence is semantically identical to the above:<P>
<PRE>
Try2            proc
                try
                
                lesi    InputLine
                gets
                stoi
                add     ax, 1000
                into
                
                Exception $Conversion
                print     nl,&quot;Illegal value, please reenter&quot;,nl
                mov     GoodInput,0
                
                endtry
                ret
Try2            endp
                 .
                 .
                 .
                InitExcept
                 .
                 .
                 .
                try
                
NumInLoop:      print   &quot;Enter an integer value:&quot;
                mov     GoodInput, 1

                call    Try2                
                
                cmp     GoodInput, 1
                jne     NumInLoop
                
                
                Exception $Overflow
                print     &quot;The number was too large, using default value&quot;,nl
                mov     ax, 1000
                
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
 Although you can next a try..endtry block within the try section, you cannot next a try..endtry block within an exception handler.  The TRY and ENDTRY statements will emit an error if you lexically nest one try..endtry block within an exception handler.  You can, however, dynamically  nest a try..endtry block within an exception handler.  That is, if you call a procedure from an exception handler and that procedure has a try..endtry block in it, things should  work okay (this has not had exhaustive testing, though).<P>
 The try..endtry blocks do not allow resumption of the failed code.  Whenever an exception occurs the system peels the stack back to the point it was at when it executed the corresponding try statement.  This means that it is impossible to return from any subroutines called inside the try..endtry block or recover any data pushed onto the stack inside the try..endtry block.  Keep this in mind when using try..endtry blocks. <P>
 Warning:  since TRY pushes data onto the stack that ENDTRY pops, should should not, under any circumstances, jump into the middle of a try..endtry block from outside that block or jump out of a try..endtry block.  Doing so will corrupt the exception handling system and the stack.<P>
<A NAME=HEADING1-145></A>
<HR>
<H2>8.3  Standard Exception Constants</H2>
 The exceptions package currently supports 11 built-in exceptions.  The values for these constants are<P>
 The standard library reserves exception codes 0..63 for hardware traps, interrupts, and exceptions;  it reserves exception codes 64..127 for system (stdlib) exceptions.  Exception codes 128 and up are available for user-defined exceptions (see the Raise statement later).<P>
 The $CritErr exception is a special case.  DOS provides a workable, if not suitable, default exception handler for critical errors (this handler prints the &quot;Abort, Retry, Ignore, or Fail&quot; message.  By default, the InitExcept statement does not replace the DOS default handler for critical errors.  If you really want to take control of this handler, see the sections on InitExcept and InitEx24.<P>
 The constants listed above contain a &quot;$&quot; prefix to avoid name space pollution (that is, to avoid conflicts with names in your programs).  This names should remain fixed despite the earlier warning about using names that begin with a &quot;$&quot; symbol.<P>
<A NAME=HEADING1-150></A>
<HR>
<H2>8.4  Try, EndTry</H2>
 The TRY statement begins a try..endtry block.  This statement pushes an eight-byte  &quot;exception record&quot; on to the stack, it pushes the address of the first exception handler in the try..endtry block onto the stack, and then it calls the stdlib $Try routine to initialize the current try..endtry block.  On return, the exception frame will still be sitting on the stack.  <P>
 You must not disturb this exception frame.  It is the link between the current try..endtry exception handler and any  enclosing try..endtry block (possibly the system default handler). <P>
 Executing the EndTry statement restores SS:SP so that it points at this exception frame and removes this exception frame from the stack.  Note that any data pushed on the stack within the try..endtry block is lost at this point.<P>
<A NAME=HEADING1-154></A>
<HR>
<H2>8.4.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-155></A>
<HR>
<H2>8.4.2  Syntax &amp; Examples</H2>
<PRE>
                InitExcept
                 .
                 .
                 .
                try
                 .
                 .
                 .
        &lt;Code that may produce an exception&gt;
                 .
                 .
                 .
        &lt;presumably, some exception handlers go here&gt;
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx
</PRE>
<A NAME=HEADING1-177></A>
<HR>
<H2>8.5  InitExcept, InitEx24, CleanUpEx</H2>
 The InitExcept and InitEx24 statements initialize the stdlib exceptions package.  InitExcept initializes the exceptions package by initializing internal variables and patching into the 80x86 interrupt vectors for the Int 0 (divide error), Int 4 (overflow error), Int 5 (bounds violation), Int 6 (invalid opcode), and Int 23h (control-C) traps.  By default, InitExcept does not  patch into the Int 24h (critical error) interrupt vector.  You must make a second call to InitEx24 to accomplish this.<P>
 Int 24h contains a reasonable default handler.  Patching into the Int 24h interrupt vector would disable this default handler and force the user to supply their own.  Since the user may not want to supply their own Int 24h handler, requiring a separate call to patch into Int 24h saves them the hassle.  The other hardware traps provide default handlers that are no better than the one provided by the exceptions package.  This is why they do not require any special handling.  As a general rule, you should never call InitEx24 without first calling the InitExcepts routine.<P>
 The CleanUpEx statement restores the 80x86's interrupt vectors to their state prior to the InitExcept and InitEx24 calls.  If you call InitExcept (and possibly InitEx24) you must call CleanUpEx before your program terminates, but after existing the last try..endtry block in your program.  Failure to terminate your program without calling CleanUpEx may leave the system in an unstable state that will require a reboot (since you will not have restored the Int 0, Int 4, Int 5, and Int 6 vectors).   Note that DOS automatically restores the Int 23h and Int 24h vectors when the program quits, although CleanUpEx does this as well.<P>
<A NAME=HEADING1-181></A>
<HR>
<H2>8.5.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-182></A>
<HR>
<H2>8.5.2  Syntax &amp; Examples</H2>
<PRE>
                InitExcept
                InitEx24
                 .
                 .
                 .
                try
                 .
                 .
                 .
        &lt;Code that may produce an exception&gt;
                 .
                 .
                 .
        &lt;presumably, some exception handlers go here&gt;
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx
</PRE>
<A NAME=HEADING1-205></A>
<HR>
<H2>8.5.3  Alternate Syntax</H2>
 InitExcept provides an alternate syntax that lets you call the InitEx24 routine as well as the InitExcept routine.  If you supply &quot;$CritErr&quot; as an operand to the InitExcept, it will automatically initialize the InitEx24 stuff as well as the standard exception handler.<P>
<PRE>
                InitExcept $CritErr
                 .
                 .
                 .
                try
                 .
                 .
                 .
        &lt;Code that may produce an exception&gt;
                 .
                 .
                 .
        &lt;presumably, some exception handlers go here&gt;
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx

</PRE>
<A NAME=HEADING1-229></A>
<HR>
<H2>8.6  EnableExcept, DisableExcept, GetXEnabled</H2>
 Certain standard library routines check an internal flag to determine whether to raise an exception.  You can enable, disable, and read the current status of this flag using the EnableExcept, DisableExcept, and GetXEnabled calls.<P>
 EnableExcept enables certain exceptions by storing a one into the internal $XEnabled variable.  This is the default setting (i.e., InitExcept initializes this variable to one).<P>
 DisableExcept disables certain exceptions by writing a zero to the internal $XEnabled variable.   Calling CleanUpEx also sets this variable to zero.<P>
 The GetXEnabled statement returns the current value of the $XEnabled variable in the AX register.  Your own programs can make this call to fetch $XEnabled to determine if it is okay to raise an exception.  By convention, your program should not raise any exceptions if this variable contains zero.<P>
 Note that the status of the $XEnabled variable does not affect the hardware or DOS traps since they are unaware of this variable.  Therefore, if one of these traps occur, you must be prepared to handle it even if the $XEnabled variable contains zero.  All standard library routines that raise exceptions respect this flag.  As a general rule, if you write code that raises exceptions, you should test the value of this flag before actually raising the exception as well.  Procedures that do not raise exceptions because $XEnabled is zero should attempt to return an error status to the caller using some other mechanism.<P>
<A NAME=HEADING1-235></A>
<HR>
<H2>8.6.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-236></A>
<HR>
<H2>8.6.2  Syntax &amp; Examples</H2>
<PRE>
                InitExcept
                InitEx24
                 .
                 .
                 .
                try
                 .
                 .
                 .
        &lt;Code that may produce an exception&gt;
                 .
                 .
                 .
                DisableExcept
                 .
                 .
                 .
        &lt;Code that only generates hardware exceptions&gt;
                 .
                 .
                 .
                EnableExcept
                 .
                 .
                 .
        &lt;Back to handling all exceptions&gt;
                 .
                 .
                 .
                Get$XEnabled
                cmp     ax, 1
                jne     SkipRaise
                mov     ax, 1234        ;User defined exception #.
                Raise
SkipRaise:
                 .
                 .
                 .
        &lt;presumably, some exception handlers go here&gt;
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx
</PRE>
<A NAME=HEADING1-284></A>
<HR>
<H2>8.7  Raise</H2>
 The Raise statement lets you generate user-defined exceptions.  To use this statement you simply load the AX register with the exception number you wish to generate and then execute the Raise statement.  This transfers control to the appropriate exception handler (to the system default exception handler if no corresponding exception handler is active).<P>
 As a general rule, you should test the state of the $XEnabled flag before raising an exception. (see the GetXEnabled, EnableExcept, and DisableExcept routines above).  Many programs may termporarily disable exceptions by setting this flag to zero.  You should not raise any exceptions while this flag is zero.<P>
 Raise is not  a subroutine call.  Once control transfers to an exception handler, it never returns to the statement after the Raise (indeed, Raise is implemented as a jmp, not a call).  Remember, there is no implicit way to resume code that has raised an exception.<P>
<A NAME=HEADING1-288></A>
<HR>
<H2>8.7.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-289></A>
<HR>
<H2>8.7.2  Syntax &amp; Examples</H2>
<PRE>
                InitExcept
                InitEx24
                 .
                 .
                 .
                try
                 .
                 .
                 .
        &lt;Code that may produce an exception&gt;
                 .
                 .
                 .
                DisableExcept
                 .
                 .
                 .
        &lt;Code that only generates hardware exceptions&gt;
                 .
                 .
                 .
                EnableExcept
                 .
                 .
                 .
        &lt;Back to handling all exceptions&gt;
                 .
                 .
                 .
                Get$XEnabled
                cmp     ax, 1
                jne     SkipRaise
                mov     ax, 1234        ;User defined exception #.
                Raise
SkipRaise:
                 .
                 .
                 .
        &lt;presumably, some exception handlers go here&gt;
                 .
                 .
                 .
                endtry
                 .
                 .
                 .
                CleanUpEx
</PRE>
<A NAME=HEADING1-337></A>
<HR>
<H2>8.7.3  Alternate Syntax</H2>
 The Raise call provides an alternate syntax where you can supply an exception number as the parameter.  Raise emits an instruction that loads the AX register with this value prior to jumping to the current exception handler:<P>
<PRE>
		raise	$Conversion
		 .
		 .
		 .
		raise	MyOwnException

</PRE>
<A NAME=HEADING1-345></A>
<HR>
<H2>8.8  PassExcept</H2>
 Occasionally the need arises in an exception handler to pass control to a previous group of exception handlers in an enclosing try..endtry block.  By default, a try..endtry block will do this if it does not have an appropriate handler for the current exception.   Once in a while you may want to raise another exception (or even the same exception) within an exception handler.  However, if you raise an exception within an exception handler, the exception is passed to the same set of exception handlers in the current try..endtry block, not the exception handlers in the enclosing block.  While this behavoir might be suitable in some instances, most of the time you'd probably prefer to pass the exception to the exception handlers in the outside try..endtry block. <P>
 This is especially important if you've trapped a specific exception and you want to call the handler for that same exception in the enclosing block.  If you were to simply reraise the exception with the Raise statement, you'd call the same handler and wind up generating an infinite loop.<P>
 The solution is to use the PassExcept call.  The semantics of PassException are identical to Raise except that PassExcept skips the exception handlers in the current try..endtry block and transfers control to the enclosing block (if no explicit try..endtry block exists in your code, PassExcept transfers control to the system default exception handler).<P>
<A NAME=HEADING1-349></A>
<HR>
<H2>8.8.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-350></A>
<HR>
<H2>8.8.2  Syntax &amp; Examples</H2>
<PRE>
                InitExcept
                InitEx24
                 .
                 .
                 .
                try                    ;Enclosing try..endtry block.

                try                    ;Current try..endtry block.
                 .
                 .
                 .
        &lt;Code that may produce an exception&gt;
                 .
                 .
                 .
                exception $Break

       &lt;Code that handles this exception&gt;

                mov     ax, 1234        ;Pass control to an enclosing
                PassExcept              ; try..except block.

        &lt;presumably, some other exception handlers go here&gt;
                 .
                 .
                 .
                endtry                   ;End of nested try..endtry block.
                 .
                 .
                 .
                exception 1234           ;The user defined exception we
                 .                       ; pass from the try..endtry block
      &lt;Appropriate 1234 handler&gt;         ; above.
                 .
                 .
                 .
                endtry                   ;End of outside try..endtry block.
                 .
                 .
                 .
                CleanUpEx
</PRE>
<A NAME=HEADING1-392></A>
<HR>
<H2>8.8.3  Alternate Syntax</H2>
 Like the Raise call, PassExcept provides an alternate syntax where you can supply an exception number as the parameter.  PassExcept emits an instruction that loads the AX register with this value prior to jumping to the current exception handler:<P>
<PRE>
		PassExcept $Conversion
		 .
		 .
		 .
		PassExcept MyOwnException

</PRE>
<A NAME=HEADING1-400></A>
<HR>
<H2>8.9  Exception</H2>
 The EXCEPTION statement lets you define an exception within a try..endtry block.  This statement takes two forms: one with a 16-bit exception number constant and one without any parameters.  The following examples show typical exception statements that have parameters:<P>
<PRE>
                exception $Break
                exception MyException
                exception 256

                exception

</PRE>
 If an exception occurs in the body of a try..endtry block,  the system transfers control to the first exception statement in the try..endtry block.  The exception statement compares the value in AX (the exception number) against the parameter of the exception statement.  If the value in AX is equal to the exception statement's parameter, program execution continues with the statement immediately following the exception statement.  If the value in AX is not equal to the exception statement's parameter, control transfers to the next exception statement in the try..endtry block and this process repeats.<P>
 If the search for a matching exception encounters the generic exception statement (i.e., an exception statement without any parameters), then that exception handler takes control.  The generic exception handler can determine the source of the exception by examining the exception number in the AX register. <P>
 If the search for an exception handler fails to find a matching exception or a generic exception handler (i.e., the search encounters the endtry statement), then the exception processing system searches for the current exception in the enclosing try..except block.  If no such block exists, control transfers to the system default exception handler that prints a brief message and terminates the program.<P>
 If the exception handling system locates an appropriate exception handler, execution continues with the body of that exception handler (the code immediately following the exception statement).  Execution continues until the exception handler encounters the next exception statement or the endtry statement.  At that point the system removes the current exception frame from the stack (along with any data pushed on the stack after the exception frame) and executes the first statement following the endtry statement.<P>
<A NAME=HEADING1-412></A>
<HR>
<H2>8.9.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-413></A>
<HR>
<H2>8.9.2  Syntax &amp; Examples</H2>
<PRE>
                InitExcept
                InitEx24
                 .
                 .
                 .
                try                    ;Enclosing try..endtry block.

                try                    ;Current try..endtry block.
                 .
                 .
                 .
        &lt;Code that may produce an exception&gt;
                 .
                 .
                 .
                exception $Break

       &lt;Code that handles this exception&gt;

                mov     ax, 1234        ;Pass control to an enclosing
                PassExcept              ; try..except block.

        &lt;presumably, some other exception handlers go here&gt;
                 .
                 .
                 .
                endtry                   ;End of nested try..endtry block.
                 .
                 .
                 .
                exception 1234           ;The user defined exception we
                 .                       ; pass from the try..endtry block
      &lt;Appropriate 1234 handler&gt;         ; above.
                 .
                 .
                 .
                exception                ;Generic exception handler
                 .
                 .
                 .
                endtry                   ;End of outside try..endtry block.
                 .
                 .
                 .
                CleanUpEx
</PRE>
<A NAME=HEADING1-459></A>
<HR>
<H2>8.9.3  Alternate Syntax</H2>
 The exception statement provides two forms: one with a single parameter and one without any parameters.  The standard form is with a single parameter (a constant) that specifies the exception number to handle.  Without any parameters, the exception handler catches all exceptions.  The body of this generic exception handler can test the source of the exception by looking at the value in the AX register.<P>
<A NAME=HEADING1-461></A>
<HR>
<H2>8.10  Critical Error Exceptions</H2>
 The critical error exception handler presents a sticky problem.  DOS provides a reasonable default handler with one minor exception - it is possible to abort the program and return control to DOS without the opportunity to call CleanUpEx thereby leaving the interrupt vectors in an unstable state.  Therefore, you should always provide a handler of some sort for the Int 24h handler (critical error handler).  This exceptions package does not supply this since critical error exceptions are relatively rare.<P>
 There are two possibilities for handling critical error exceptions: write your own INT 24h interrupt service routine (arguably the best solution) or write an exception handler within the try..endtry block.  Writing your own Int 24h ISR is beyond the scope of this document.  See a text such as &quot;The Art of Assembly Language Programming&quot; for more details on writing Int 24h ISRs.<P>
 This section will discuss the other alternative, writing your own exception handler in a try..endtry block.  Given the nature of the Int 24h exception, there are some special concerns for those writing the $CritErr handler.<P>
 The first thing to note is that the exception dispatching mechanism passes additional information to the critical error handler.  In particular, the ES:DI register pair points at a data structure that contains the following information:<P>
 DOS pushed these values onto the stack upon initial entry.  By looking at these values you can determine the type of DOS call (using the value in AH) and any necessary parameters appearing in registers for that call.<P>
 Since you have access to the return address (CS:IP in the structure above), you can return control to the program at the point of the offending DOS call and resume execution at that point.  This makes the Critical Error handler somewhat special since it is possible to resume execution unlike most other exception handlers.<P>
 You can also call DOS again, but be aware that if DOS generates another critical error there will be a reentrant call to your handler that will disturb the register values above (in particular, the return address values).<P>
 A typical Critical Error Exception handler should ask the user if they want to continue program execution ignoring the error, retry the operation,  return a DOS failure code to the program, or quit the program.  To retry the operation, you would save the application return address, load the registers with the values from the structure above, and then reissue the DOS call (int 21h). To ignore the error, you would simply return to the application (via the CS:IP address in the structure above) with the carry flag clear and other appropriate return values in the registers.  To fail, you would return to the program (through CS:IP above) with the carry flag set and an appropriate error code in AX.  To abort the program, you should call CleanUpEx to restore the system interrupt vectors and then return control to DOS (e.g., by using the ExitPgm macro).<P>
 Note that the exception handling system makes a quick call to DOS in the internal Int 24h handler.  This is because DOS is unstable until someone makes a call to DOS with a function number greater than 12.  The internal int 24h ISR call DOS and request the current state of the break flag in order to get DOS into a consistent state.  This should have zero impact on your exception handler.<P>
 <P>
</BODY>
</HTML> 