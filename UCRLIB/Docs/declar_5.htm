<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE> </TITLE>
</HEAD>
<BODY>
<A NAME=HEADING1></A>
Declarations<P>
<HR>
<!-- TOC --><DL>
<DT><A HREF="declar_1.htm#HEADING1-1"><B></B>Declarations</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-6"><B>7.0	</B> - Interface</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-14"><B>7.1	</B> - Overview of Declarations</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-16"><B>7.2	</B> - Var, Endvar</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-38"><B>7.2.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-53"><B>7.2.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-59"><B>7.3	</B> - DclType</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-120"><B>7.3.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-128"><B>7.3.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-145"><B>7.4	</B> - Index</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-150"><B>7.4.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-158"><B>7.4.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-176"><B>7.5	</B> - InitList</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-180"><B>7.5.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-188"><B>7.5.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-195"><B>7.6	</B> - Enum</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-211"><B>7.6.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-219"><B>7.6.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="declar_1.htm#HEADING1-232"><B>7.7	</B> - Predefined Types</A>
<DD>
</DL>

<A NAME=HEADING1-0></A>
<H1></H1>
<HR>
<A NAME=HEADING1-1></A>
<H1> Declarations</H1>
 The declarations package in the UCR Standard Library contains several macros that let you define variables using a high level language (HLL) syntax rather than standard assembly language syntax.  These macros automatically convert such declarations into their MASM counterparts.<P>
 The declarations package provides HLL definitions for Integer, Unsigned, Long, ULong (unsigned long), Char, String, Hex, SHex (short hex),  Boolean, Float, Double, and Extended (long double) data types.  It is very easy to add new types to this list.<P>
 The declarations package also contains a macro that makes it easy to create enumerated data types.  This spares you the trouble of generating a list of sequential constants manually.<P>
 The declarations package also contains some macros that provide some &quot;syntactical sugar&quot; and Stream I/O macros to support I/O via the Stream I/O operations.<P>
<A NAME=HEADING1-6></A>
<HR>
<H2>7.0  Interface</H2>
 To access the routines in the declarations  package, your assembly language module must include the file &quot;dcls.a&quot; during assembly.  You can accomplish this with either of the following include statements in your assembly code:<P>
<PRE>
	include	dcls.a
or
	include	ucrlib.a

</PRE>
 The dcls.a include file exports several symbols.  The UCR Standard Library prefaces all &quot;private&quot; names with a dollar sign (&quot;$&quot;).  You should not call any routine in this package that begins with this symbol unless otherwise advised.  To avoid name conflicts, you should not define any symbols in your programs that begin with a dollar sign (&quot;$&quot;).  Note that future versions of the stdlib (that remain compatible with this release)  may change &quot;private&quot; names.  To remain compatible with future releases, you must not refer to these &quot;private&quot; names within your programs.<P>
 Source code appearing in this chapter is current as of Version Two, Release 40.   There may be minor changes between this source code and the current release.<P>
<A NAME=HEADING1-14></A>
<HR>
<H2>7.1  Overview of Declarations</H2>
 The declarations package contains five primary macros you would use to create new data types: var, endvar, enum, InitList, and DclType.  In addition, this package contains a macro (INDEX) that computes the index into a two dimensional array.  Finally, this package contains declarations for the stdlib &quot;built-in&quot; data types.<P>
<A NAME=HEADING1-16></A>
<HR>
<H2>7.2  Var, Endvar</H2>
 The Var and Endvar macros delimit a variable declarations section.  Actually, the use of these macros is purely optional.  All they do is emit the following statements:<P>
<PRE>
Var:	dseg		segment		para public 'DATA'
Endvar:	dseg		ends

</PRE>
 You can declare your variables in any appropriate segment.  However, most programs that use the Standard Library place all global variables in a segment named &quot;dseg&quot;.  Therefore, the macros above are convenient since they automatically include any declarations between them in the &quot;dseg&quot; segment.<P>
 Note that all variables you declare between Var and Endvar are global and static, regardless of where you place VAR..ENDVAR in your program.   If you insert VAR..ENDVAR in a procedure, the names are not local to that procedure, nor is the variable's lifetime limited to the execution time of that procedure.  VAR..ENDVAR and static and global in every sense of the word.<P>
 Note that it is okay to insert variable declarations into the middle of code as long as you have the VAR..ENDVAR macros around such declarations.  MASM will automatically move such declarations out of your code stream and into the data segment.  The following example is perfectly legal:<P>
<PRE>
MyProc	proc	near
var
    integer i,j,k
    float f,x
    char cArray[28]
endvar

	mov	i, 0
	mov	j, 1
	 .
	 .
	 .

</PRE>
 Note, however, that if  you leave the surrounding VAR..ENDVAR declarations out of the above example, MASM would emit the bytes for these variable declarations directly in the code stream.  This would probably create havoc when you attempt to call MyProc.<P>
<A NAME=HEADING1-38></A>
<HR>
<H2>7.2.1  Calling Conventions and Assertions</H2>
<BLOCKQUOTE>
Var:<P>
Inputs: None.<P>
Outputs: None.<P>
Errors: None.<P>
Side Effects: Opens a DSEG declaration at point of invocation.<P>
Assertions: None.<P>
<P>
Endvar:<P>
Inputs: None.<P>
Outputs: None.<P>
Errors: None.<P>
Side Effects: Closes a DSEG declaration at point of invocation.<P>
Assertions: None.<P>
<P>
</BLOCKQUOTE>
<A NAME=HEADING1-53></A>
<HR>
<H2>7.2.2  Syntax &amp; Examples</H2>
<PRE>
var
    integer i,j,k
    float f[20]
endvar

</PRE>
<A NAME=HEADING1-59></A>
<HR>
<H2>7.3  DclType</H2>
 The DclType macro lets you declare your own &quot;stdlib-aware&quot; data types.  The main purpose of this macro is to create data types for use in the VAR..ENDVAR section.  <P>
 The DclType macro requires two parameters: a new type name and an existing (MASM) type name.  A typical call takes the following form:<P>
<PRE>
	DclType	integer, sword

</PRE>
 The first difference between a DclType and a typedef typename is the syntax of the declaration.  Consider the integer declaration above.  To declare variables of type integer, you would use a statement like the following:<P>
<PRE>
	integer	i

	integer	i,k,j

	integer	*pi, i, j, *pj

</PRE>
 You can also declare one, two, three, and higher dimensional arrays, again using C/C++ style syntax:<P>
<PRE>
	integer	iarray[20], array2d[10][10], array3d[2][4][6]

</PRE>
 Finally, also similar to  C/C++, you place initializers after an identifier in the declaration list:<P>
<PRE>
	integer	i=10, j=20

	integer	*pi=i

	integer	iarray[10]=1			;Inits &quot;iarray&quot; with 10 ones.

</PRE>
 Suppose you have the following DclType declaration:<P>
<PRE>
	DclType	integer, sword

i	sword	?

</PRE>
 If MASM encounters a statement of the form &quot;integer *pi&quot; it emits the following statement:<P>
<PRE>
pi	dword	?

</PRE>
 If you declare an array using a statement like &quot;integer iarray[10]&quot;, then the integer macro will emit the following code:<P>
<PRE>
iarray	sword	10 dup (?)

</PRE>
 If you declare two (or higher) dimensional arrays, like &quot;integer array2d[10][8]&quot; then the integer macro generates the following code:<P>
<PRE>
array2d	sword	10 dup (8 dup (?))

array3d	sword	2 dup (4 dup (6 dup (?)))

</PRE>
 If you place an asterisk (&quot;*&quot;) in front of an array declaration, the integer macro (and any macro generated by DclType) will emit a declaration for an array of pointers.  For example, &quot;integer *ia[10]&quot; emits the following code:<P>
<PRE>
ia	dword	10 dup (?)

</PRE>
 If you add an initializer value in the declaration, the integer macro will replace the &quot;?&quot; in the operand field by that value.  For example, &quot;integer i=10, *pi=i, ia[10]=2&quot; emits the following code:<P>
<PRE>
i	sword	10
pi	dword	i
ia	sword	10 dup (2)

</PRE>
 In addition to changing the syntax of a variable declaration, the macros DclType generates do one other thing that a typedef defined type does not - they create some special symbols you can use to test the type of a variable in your assembly code.  Whenever you declare a variable with a DclType generated macro (e.g., integer), the macro emits two statements.  The first, of course, is the variable declaration as described above.  The second is a textequ statement that takes the following form:<P>
<PRE>
$?varname	textequ	&lt;typename&gt;

i	sword	?
$?i	textequ	&lt;integer&gt;
j	sword	?
$?j	textequ	&lt;integer&gt;
k	sword	?
$?k	textequ	&lt;integer&gt;

</PRE>
 If you declare a pointer type, e.g., &quot;integer *pi&quot; then the typename in the operand field of the textequ statement has an asterisk prefixed to the type name.  For example, given &quot;integer *pi&quot; the corresponding assembly code will be:<P>
<PRE>
pi	dword	?
$?pi	textequ	&lt;*integer&gt;

</PRE>
 By default, DclType macros emit the &quot;?&quot; symbol to denote an unitialized value.  This works great for most scalar and array data types.  However, structure data types require that you use &quot;{}&quot; rather than a &quot;?&quot; to denote unitialized structures.  The DclType macro allows for an optional third operand that lets you tell DclType that you are creating a structure type and you need to use &quot;{&quot; and &quot;}&quot; in the operand field rather than &quot;?&quot;.  If there is a third operand present, the the macro the DclType generates will surround the initial operand with braces (&quot;{&quot; and &quot;}&quot;).  It will place an empty set of braces in the operand field if there is no initial value.  See the example for details.<P>
<A NAME=HEADING1-120></A>
<HR>
<H2>7.3.1  Calling Conventions and Assertions</H2>
<BLOCKQUOTE>
DclType:<P>
Inputs: Operand1: a new type name.  Operand2: the corresponding MASM type to associate with this type name.<P>
Outputs: A macro that will let you declare variables of this new type.<P>
Errors: None.<P>
Side Effects: None.<P>
Assertions: None.<P>
<P>
</BLOCKQUOTE>
<A NAME=HEADING1-128></A>
<HR>
<H2>7.3.2  Syntax &amp; Examples</H2>
<PRE>
stype	struct
Name	dword	?	;Pointer to name
Age	word	?
SSN	char	11	;Social Security Number
stype	ends
	 .
	 .
	 .
; Note the third operand is present in DclType below because we are
; creating a structure type.

	DclType	Student, stype, &lt;{}&gt;
	 .
	 .
	 .
	Student	Class
</PRE>
<A NAME=HEADING1-145></A>
<HR>
<H2>7.4  Index</H2>
 The Index macro automatically generates the necessary code to access an element of a two dimensional array.  You supply it the name of a two dimensional array, a row value, a column value, and an optional register.  The Index macro computes <P>
<PRE>
	(row*(size of a row) + column) * SizeOfElement

</PRE>
 The row and column values must be 16-bit values.  They can be constants, registers, or memory locations (using any reasonable memory addressing mode).<P>
<A NAME=HEADING1-150></A>
<HR>
<H2>7.4.1  Calling Conventions and Assertions</H2>
<BLOCKQUOTE>
Index:<P>
Inputs: Operand1: an array name.  Operand2:  the row number. Operand3: the column number. Operand4 (optional): a 16-bit register to use (BX, SI, or DI are the best choices).<P>
Outputs: 80x86 code that computes the row-major ordering function for a two-dimensional array.<P>
Errors: None.<P>
Side Effects: Generated code modifies the BX register if  you do not specify the register to use.<P>
Assertions: None.<P>
<P>
</BLOCKQUOTE>
<A NAME=HEADING1-158></A>
<HR>
<H2>7.4.2  Syntax &amp; Examples</H2>
 The following code (using the ForLp macro from the control.a include file) fills a two-dimensonal array with incrementing values:<P>
<PRE>
var
    integer i,j, counter
    integer a[20][30]
endvar

	mov	counter, 0
	ForLp	I, 0, 19
	ForLp	J, 0, 29

	index	a, I, J
	mov	a[bx], counter
	inc	counter

	next	J
	next	I

</PRE>
<A NAME=HEADING1-176></A>
<HR>
<H2>7.5  InitList</H2>
 The type definition macros that DclType generates suffer from one major drawback- it is difficult to initialize an array (or other object) with more than a single value.  Using standard MASM directives, it is easy to generate a table of objects using a statement like:<P>
<PRE>
table	word	1,2,3,4,5,6,7,8

</PRE>
<A NAME=HEADING1-180></A>
<HR>
<H2>7.5.1  Calling Conventions and Assertions</H2>
<BLOCKQUOTE>
InitList:<P>
Inputs: A list of initial values (surrounded by parentheses).<P>
Outputs: A textual data object that a DclType generated macro can use to initialize a list of values.<P>
Errors: None.<P>
Side Effects: None.<P>
Assertions: None.<P>
<P>
</BLOCKQUOTE>
<A NAME=HEADING1-188></A>
<HR>
<H2>7.5.2  Syntax &amp; Examples</H2>
<PRE>
integer table=InitList(1,2,3,4,5,6,7,8)

integer vals[8]=InitList(0,1,2,3)

Vals	sword	8 dup (1,2,3,4)

</PRE>
<A NAME=HEADING1-195></A>
<HR>
<H2>7.6  Enum</H2>
  The Enum statement lets you easily create an enumerated data type.  An enumerated data type is a list of named constants, each given a unique name.  In the past, assembly language programmers would have created an enumerated list using code like this:<P>
<PRE>
item1	=	0
item2	=	1
item3	=	2
 .	.	.
 .	.	.
 .	.	.

ItemVar	byte	?

enum	Items, &lt;item1, item2, item3, ...&gt;

Items	ItemVar

</PRE>
 Note that Enum associates the value zero with the first item in the list.  It assigns consecutive values to the following items in the constant list.<P>
<A NAME=HEADING1-211></A>
<HR>
<H2>7.6.1  Calling Conventions and Assertions</H2>
<BLOCKQUOTE>
enum:<P>
Inputs: The name of the new data type (Operand1) and a list of named values for that type.<P>
Outputs: A new DclType macro (using the name you've supplied) and a list of constant declarations for the type.<P>
Errors: None.<P>
Side Effects: None.<P>
Assertions: None.<P>
<P>
</BLOCKQUOTE>
<A NAME=HEADING1-219></A>
<HR>
<H2>7.6.2  Syntax &amp; Examples</H2>
<PRE>
enum	color,&lt;red, orange, yellow, green, blue, purple&gt;

var
    color	c1, c2=red, RGB=InitList(red, green blue)
endvar

	mov	cl, red
	cmp	c2, red
	je	IsRead
	 .
	 .
	 .
</PRE>
<A NAME=HEADING1-232></A>
<HR>
<H2>7.7  Predefined Types</H2>
 The stdlib DCL.A include file provides definitions for 12 common types.  This includes six common integer types, three floating point types, two character/string types, and a boolean data type.<P>
 The integer types include the following:<P>
<BLOCKQUOTE>
integer: 16-bit signed integer values.  Defined as sword.<P>
unsigned: 16-bit unsigned integer values. Defined as word.<P>
long: 32-bit signed integer values. Defined as sdword.<P>
ulong: 32-bit unsigned integer values. Defined as dword.<P>
shex: 8-bit hexadecimal values. Defined as byte.<P>
hex: 16-bit hexadecimal values. Defined as word.<P>
<P>
</BLOCKQUOTE>
 The floating point types include the following:<P>
<BLOCKQUOTE>
float: 32-bit single precision floating point values.  Defined as real4.<P>
double: 64-bit double precision floating point values.  Defined as real8.<P>
extended: 80-bit extended precision floating point values.  Defined as real10.<P>
<P>
</BLOCKQUOTE>
 The character types include the following:<P>
<PRE>
char:	one-byte character variables.  Defined as byte.
string:	Also one-byte character variables.  Defined as byte.

</PRE>
 Boolean data type:<P>
<PRE>
boolean:	enumerated data type.  Defined as byte.
	Predefined constants: false=0, true=1.

</PRE>
 The primary difference between the char and string data types is with respect to the support provided for these types in the Stream I/O package.  When reading or writing a character variable, the Stream I/O package always reads or writes a single character.  When reading or writing strings, the Stream I/O package processes entire zero terminated strings.<P>
 The DCLS.A package also includes the necessary interface macros for the Stream I/O system.  See the documentation for the Stream I/O package for more details.<P>
</BODY>
</HTML> 