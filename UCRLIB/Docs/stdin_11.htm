<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE> </TITLE>
</HEAD>
<BODY>
<A NAME=HEADING1></A>
UCR Stdlib Standard Input Routines<P>
<HR>
<!-- TOC --><DL>
<DT><A HREF="stdin_1.htm#HEADING1-1"><B></B>UCR StdLib Standard Input Routines</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-4"><B>13.1	</B> - Interface</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-12"><B>13.2	</B> - Generic Interface</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-36"><B>13.3	</B> - Buffered vs. Raw Input Formats</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-43"><B>13.4	</B> - Getc, GetcCS, GetcStk</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-45"><B>13.4.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-46"><B>13.4.2	</B> - Getc Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-51"><B>13.4.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-109"><B>13.5	</B> - Peekc, PeekcCS, PeekcStk</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-113"><B>13.5.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-114"><B>13.5.2	</B> - Peekc Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-119"><B>13.5.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-151"><B>13.6	</B> - Gets, GetsCS, GetsStk, Getsm</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-158"><B>13.6.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-159"><B>13.6.2	</B> - Gets Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-164"><B>13.6.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-181"><B>13.7	</B> - GetcLen, GetcLenCS, GetcLenStk</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-183"><B>13.7.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-184"><B>13.7.2	</B> - GetcLen Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-189"><B>13.7.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-232"><B>13.8	</B> - FlushGetc</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-234"><B>13.8.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-235"><B>13.8.2	</B> - FlushGetc Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-240"><B>13.8.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-251"><B>13.9	</B> - rawGetc</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-253"><B>13.9.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-254"><B>13.9.2	</B> - RawGetc Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-259"><B>13.9.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-268"><B>13.10	</B> - rawGets, rawGetsCS, rawGetsStk,  rawGetsm</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-271"><B>13.10.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-272"><B>13.10.2	</B> - RawGets Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-277"><B>13.10.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-319"><B>13.11	</B> - GetcStdIn</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-324"><B>13.11.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-325"><B>13.11.2	</B> - GetcStdIn Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-329"><B>13.11.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-363"><B>13.12	</B> - GetcBIOS</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-367"><B>13.12.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-368"><B>13.12.2	</B> - GetcBIOS Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-372"><B>13.12.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-397"><B>13.13	</B> - SetInAdrs, GetInAdrs</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-403"><B>13.13.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-404"><B>13.13.2	</B> - GetInAdrs, SetInAdrs Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-408"><B>13.13.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-462"><B>13.14	</B> - PushInAdrs, PopInAdrs</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-466"><B>13.14.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-467"><B>13.14.2	</B> - PushInAdrs, PopInAdrs Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-471"><B>13.14.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-497"><B>13.15	</B> - ResetStdIn</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-499"><B>13.15.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-500"><B>13.15.2	</B> - ResetStdIn Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-504"><B>13.15.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-513"><B>13.16	</B> - tstKbd</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-516"><B>13.16.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-517"><B>13.16.2	</B> - TestKbd Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-521"><B>13.16.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-539"><B>13.17	</B> - tstInput</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-541"><B>13.17.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-542"><B>13.17.2	</B> - TstInput Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-546"><B>13.17.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-564"><B>13.18	</B> - Geth, GethCS, GethStk, Gethl</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-575"><B>13.18.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-576"><B>13.18.2	</B> - Geth, Gethl Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-581"><B>13.18.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-604"><B>13.19	</B> - Geti</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-617"><B>13.19.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-618"><B>13.19.2	</B> - Geti Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-622"><B>13.19.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-639"><B>13.20	</B> - Getu</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-644"><B>13.20.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-645"><B>13.20.2	</B> - Getu Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-650"><B>13.20.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-667"><B>13.21	</B> - Getl</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-669"><B>13.21.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-670"><B>13.21.2	</B> - Getl Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-675"><B>13.21.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-692"><B>13.22	</B> - Getul</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-694"><B>13.22.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-695"><B>13.22.2	</B> - Getul Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-700"><B>13.22.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-718"><B>13.23	</B> - Getf</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-728"><B>13.23.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-729"><B>13.23.2	</B> - Getf Addressing Modes</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-734"><B>13.23.3	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-742"><B>13.24	</B> - Scanf, Scanff</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-810"><B>13.24.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-811"><B>13.24.2	</B> - Syntax &amp; Examples</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-822"><B>13.24.3	</B> - Alternate Syntax</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-829"><B>13.25	</B> - GetTermChar, SetTermChar</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-833"><B>13.25.1	</B> - Calling Conventions and Assertions</A>
<DD>
<DT><A HREF="stdin_1.htm#HEADING1-834"><B>13.25.2	</B> - Syntax &amp; Examples</A>
<DD>
</DL>

<A NAME=HEADING1-0></A>
<H1></H1>
<HR>
<A NAME=HEADING1-1></A>
<H1> UCR StdLib Standard Input Routines</H1>
 The stdlib Standard Input package provides routines that let you read data from the standard input device.  There are two primary forms of input: &quot;buffered&quot; and &quot;raw.&quot;  The &quot;raw&quot; input routines read their data directly from the standard input device.  For example, a call to the stdlib &quot;rawGetc&quot; routine reads a character directly from the standard input device.  The buffered input routines, on the other hand, read a line of data at a time from the standard input device and then return characters from this input buffer as the program requests them.  <P>
 The standard input package provides functions that read characters, strings, numeric values, and other types of data.  You may specify raw or buffered formats for string and character inputs, numeric inputs always use the buffered format.<P>
<A NAME=HEADING1-4></A>
<HR>
<H1>13.1  Interface</H1>
 To access the routines in the declarations  package, your assembly language module must include the file &quot;stdin.a&quot; during assembly.  You can accomplish this with either of the following include statements in your assembly code:<P>
<PRE>
	include	stdin.a
or
	include	ucrlib.a

</PRE>
 The stdin.a include file exports several symbols.  The UCR Standard Library prefaces all &quot;private&quot; names with a dollar sign (&quot;$&quot;).  You should not call any routine in this package that begins with this symbol unless otherwise advised.  To avoid name conflicts, you should not define any symbols in your programs that begin with a dollar sign (&quot;$&quot;).  Note that future versions of the stdlib (that remain compatible with this release)  may change &quot;private&quot; names.  To remain compatible with future releases, you must not refer to these &quot;private&quot; names within your programs.<P>
 Source code appearing in this chapter is current as of Version Two, Release 40.   There may be minor changes between this source code and the current release.<P>
<A NAME=HEADING1-12></A>
<HR>
<H1>13.2  Generic Interface</H1>
 Many of the standard library routines use a common generic programmer's interface.  Such routines let you pass parameters to them in several different locations.  Common examples include in the registers, by value in the code stream (CSi), by reference in the code stream (CS), by value on the top of stack (TOS), and by reference on the top of stack (Stk).  Typically, there are separate invocation macros defined for each of these variants, e.g.,<P>
<PRE>
	IsAlNum			;Passed in AL register.

	IsAlNumCS
	dword	chrPtr		;Passed by reference in code stream.

	push	'a'		;Passed by value on the stack.
	IsAlNumTOS

	push	seg chrVar		;Passed by reference on the stack.
	push	offset chrVar
	IsAlNumStk

</PRE>
 In addition to the above forms there are two other suffixes generally applied to stdlib routine names: &quot;m&quot; and &quot;x&quot;.  The &quot;m&quot; suffix stands for &quot;malloc&quot;.  Routines with the &quot;m&quot; suffix typically generate a string result and malloc storage for the string on the heap, returning a pointer to this string in the ES:DI register pair.  The routines with an &quot;x&quot; suffix also process strings.  Most stdlib routines preserve the value of the ES:DI registers when processing strings; typically, they leave the ES:DI register pair pointing at the start of the string.  The routines with an &quot;x&quot; suffix do not preserve ES:DI, they generally leave ES:DI pointing at the zero byte of the string they processed or generated.<P>
 To make it easier to use all these different variants, the standard library typically defines a macro for each routine that lets you specify various operands using stdlib &quot;addressing modes.&quot;  The allowable addressing modes vary by routines, but they typically take one of the following forms:<P>
<PRE>
	name		;If operand field is blank, use &quot;plain&quot; version.
	name	var	;Generally passes address of var in code stream (CS).
	name	const	;Pushes const onto TOS and uses nameTOS routine.
	name	[wvar]	;Pushes DS followed by value of wVar variable
			; (assumed to be a word) and calls nameSTK
	name	[dVar]	;Pushes dword value of dVar onto stk, calls nameStk.

</PRE>
 Since not all of these &quot;addressing modes&quot; are applicable to all instructions, and some instructions allow different sets of operands (including multiple operands), there are lots of special cases.  Such cases are noted after the explaination for each particular routine.<P>
<A NAME=HEADING1-36></A>
<HR>
<H1>13.3  Buffered vs. Raw Input Formats</H1>
 The stdlib Standard Input package provides two sets of three complementary routines for reading characters and strings: (getc, gets, and getsm) and (rawgetc, rawgets, and rawgetsm). The raw* routines (obviously) provide the raw operations, the other set provide the buffered input routines.<P>
 The rawGetc routine is the basic character input routine in the Standard Input package.  This routine jumps to the procedure that reads a character from the current input device  (typically the DOS standard input device).   The rawGets and rawGetsm (get a string) routines call rawGetc to read  a line of data directly from the standard input device.<P>
 The buffered input routines, on the other hand, read entire lines of data from the standard input device into an internal buffer and then extract characters from this buffer.  When these routines exhaust the characters in the buffer, they read another line of text from the standard input device and reset the buffer pointers to the beginning of the buffer and start over.<P>
 Buffered input allows the user to type an entire line and edit that line (e.g., using the backspace or ESC keys) before committing that data to the program.  The rawGetc routine, on the other hand, simply returns the backspace character like any other key and relies upon the user program to perform any necessary editing.<P>
 There is one detail you must consider when using buffered and raw I/O in a program: if you intermix calls to the raw and buffered routines, you may get strange results.  For example, if you call the Getc (buffered) function to read a character from the standard input, this will force the system to read an entire line of text.  Subsequent calls to Getc read characters from that same line.  However, if you intermix calls to rawGetc with calls to Getc, the rawGetc calls will read directly from the standard input ignoring the characters in the internal buffer.  This will appear to the user as though the data is being read out of order.<P>
 Because buffered I/O is somewhat &quot;safer,&quot; the numeric input routines all use buffered I/O.  Therefore, as a general rule, you should attempt to use buffered I/O for all your input operations.  Reserve raw input for the situations where you have to guarantee that the input is coming directly from the standard input device.<P>
<A NAME=HEADING1-43></A>
<HR>
<H1>13.4  Getc, GetcCS, GetcStk</H1>
 The Getc routine reads a single character from the input buffer and returns this character in the AL register.  Getc returns the carry flag clear if no error occurs.  Assuming exceptions are not active, Getc will return the carry flag set if an error occurs (while reading the buffered line of text from the standard input).  If exceptions are active, Getc (actually the call to rawGets that reads the line of text into the buffer) will raise an appropriate exception.  See the rawGets routine for more details on the possible exceptions.<P>
<A NAME=HEADING1-45></A>
<HR>
<H2>13.4.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-46></A>
<HR>
<H2>13.4.2  Getc Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Getc Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Getc<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The getc macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Getc Extended Syntax (Single/No Operands)</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Getc<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-51></A>
<HR>
<H2>13.4.3  Syntax &amp; Examples</H2>
<PRE>
cvar    byte    ?
wvar    word    cvar
dvar    dword   cvar
         .
         .
         .
        print   &quot;Enter Y or N:&quot;
        getc
        toupper
        cmp     al, 'Y'
        je      EnteredYes
         .
         .
         .
        print   &quot;Enter a character: &quot;
        getcCS
        dword   cvar
        printf  &quot;You entered %c\n&quot;, cvar
         .
         .
         .
        print   &quot;Enter a character: &quot;
        pshadrs cvar
        getcStk
        printf  &quot;You entered %c\n&quot;, cvar
         .
         .
         .


        getc            ;Leaves character in AL
        getc    cvar    ;Leaves character in byte var cvar.
        getc    [wvar]  ;ds:wvar is near ptr to dest location.
        getc    [dvar]  ;dvar contains far ptr to dest location.
         .
         .
         .
        print   &quot;Enter a character:&quot;
        getc    cvar
        printf  &quot;You entered %c\n&quot;, cvar
         .
         .
         .
        print   &quot;Enter a character:&quot;
        getc    [wvar]
        print   &quot;You entered &quot;
        putc    cvar
        putcr
         .
         .
         .
        print   &quot;Enter a character:&quot;
        getc    [dvar]
        print   &quot;You entered &quot;
        putc    cvar
        putcr

</PRE>
<A NAME=HEADING1-109></A>
<HR>
<H1>13.5  Peekc, PeekcCS, PeekcStk</H1>
 Peekc is very similar to Getc except it does not remove the character it reads from the input buffer.  If there is data in the internal Getc buffer, Peekc returns the first character in that buffer.  Future calls that would normally return a character from the buffer will return the same character Peekc read from the buffer.<P>
 If the buffer is empty when you call Peekc, the system will read a new line of text from the standard input and then return a copy of the first character in the buffer without removing that character from the buffer.<P>
 Peekc returns the carry flag clear if no error occurs.  Assuming exceptions are not active, Peekc will return the carry flag set if an error occurs (while reading the buffered line of text from the standard input).  If exceptions are active, Peekc (actually the call to rawGets that reads the line of text into the buffer) will raise an appropriate exception.  See the rawGets routine for more details on the possible exceptions.<P>
<A NAME=HEADING1-113></A>
<HR>
<H2>13.5.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-114></A>
<HR>
<H2>13.5.2  Peekc Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Peekc Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Peekc<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The peekc macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Peekc Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Peekc<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-119></A>
<HR>
<H2>13.5.3  Syntax &amp; Examples</H2>
<PRE>
	print	&quot;Enter Y or N:&quot;
	peekc
	toupper
	cmp	al, 'Y'
	je	EnteredYes
	 .
	 .
	 .

	print	&quot;Enter Y or N:&quot;
	peekcCS
	byte	YorNChar
	cmp	YorNChar, 'Y'
	je	EnteredYes
	 .
	 .
	 .

	pshadrs	YorNChar
	peekcStk
	cmp	YorNChar, 'Y'
	je	EnteredYes
	 .
	 .
	 .


	getc			;Returns character in AL
	getc	CharVar		;Puts char in CharVar
	getc	[wVar]		;Stores char where wVar points in DS
	getc	[dVar]		;Stores char where dVar points
</PRE>
<A NAME=HEADING1-151></A>
<HR>
<H1>13.6  Gets, GetsCS, GetsStk, Getsm</H1>
 Gets copies the remaining data in the internal buffer to the string variable at the address contained in ES:DI.  If the internal buffer is empty, Gets will read a new line of text from the standard input and copy that entire string to the location specified by ES:DI.  After a call to Gets, the internal buffer will be empty.  Any future call that reads data from the internal buffer will force a new input line to be read from the standard input (via rawgets).<P>
 GetsCS works like Gets except a pointer to the destination string follows the call in the code stream;  it does not use the value in ES:DI.<P>
 GetsStk is very similar to Gets except it expects the address of the destination string on the stack rather than in the ES:DI register pair.<P>
 Getsm allocates storage on the heap and copies the contents of the internal buffer to the storage allocated on the heap.  Getsm returns the address of this heap object in the ES:DI register pair.<P>
 These routines all return the error status in the carry flag.  If the carry is set on return, then some sort of error occured while attempting to input the line of text.  If exceptions are enabled, these calls will raise an appropriate exception.  This is typically an EOF, file I/O error, or memory allocation (getsm) exception.<P>
 If you use Getc to read all of the characters from the input buffer except the terminating carriage return, a call to Gets, GetsStk, or Getsm will ignore this last &quot;character&quot; in the buffer and read a new line of text from the user.  The next buffered get* call will force the system to read a new line of text from the standard input device.<P>
<A NAME=HEADING1-158></A>
<HR>
<H2>13.6.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-159></A>
<HR>
<H2>13.6.2  Gets Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Gets Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>Gets<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-<TD>X</TABLE>
<P>
 <P>
 The gets macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Gets Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Gets<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-164></A>
<HR>
<H2>13.6.3  Syntax &amp; Examples</H2>
<PRE>
Name	byte	256 dup (0)
	 .
	 .
	 .
	print	&quot;Enter your name:&quot;
	lesi	Name
	gets
	printf	&quot;Hello %s\n&quot;, Name
	 .
	 .
	 .
</PRE>
 Gets calls GetcCS with the address of &quot;byteVar&quot; following in the code stream.<P>
 <P>
 Gets assumes the word variable contains a DS-relative near pointer.  It pushes the value of DS onto the stack followed by the value of the word variable.  Then it calls GetsStk.<P>
 <P>
 Gets assumes the dword variable contains a far pointer.  It pushes the value of the dword variable onto the stack and calls GetsStk.<P>
<A NAME=HEADING1-181></A>
<HR>
<H1>13.7  GetcLen, GetcLenCS, GetcLenStk</H1>
 GetcLen returns (in CX or in a specified word variable) the number of unprocessed characters left in the internal input buffer (this does not include the terminating zero byte).<P>
<A NAME=HEADING1-183></A>
<HR>
<H2>13.7.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-184></A>
<HR>
<H2>13.7.2  GetcLen Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>GetcLen Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>GetcLen<TD>X<TD>X<TD>-<TD>X<TD>&nbsp;<TD>-</TABLE>
<P>
 <P>
 The GetcLen macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>GetcLen Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>GetcLen<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-189></A>
<HR>
<H2>13.7.3  Syntax &amp; Examples</H2>
 GetcLenxxx  macros without any parameters.<P>
 <P>
<PRE>
	getc
	mov	Char1, al
	getc
	mov	Char2, al
	GetcLen
	print	&quot;There are &quot;
	puti
	print	&quot; characters left in the buffer.&quot;
	  .
	  .
	  .
</PRE>
 <P>
<PRE>
	getc
	mov	Char1, al
	getc
	mov	Char2, al
	GetcLenCS
	dword	BufLen
	printf	&quot;There are %d characters left in the buffer.\n&quot;,BufLen
	  .
	  .
	  .

	getc
	mov	Char1, al
	getc
	mov	Char2, al
	pshAdrs	BufLen
	GetcLenStk
	printf	&quot;There are %d characters left in the buffer.\n&quot;,BufLen
	  .
	  .
	  .

The GetcLen macro also allows an extended syntax with operands specifying the particular &quot;addressing mode&quot; for the destination value:

	getcLen			;Returns length in CX.
	getcLen	wVar		;Stores length into wVar (word variable)
	getcLen	[wVar]		;Stores length where wVar points in DS.
	getcLen	[dvar]		;Stores length where dVar points.
</PRE>
<A NAME=HEADING1-232></A>
<HR>
<H1>13.8  FlushGetc</H1>
 FlushGetc flushes (clears) the internal character buffer.  The next call to a get* routine will force a new line of text to be read after a call to the FlushGetc function.<P>
<A NAME=HEADING1-234></A>
<HR>
<H2>13.8.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-235></A>
<HR>
<H2>13.8.2  FlushGetc Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>FlushGetc Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>FlushGetc<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 The FlushGetc macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>FlushGetc Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>FlushGetc<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-240></A>
<HR>
<H2>13.8.3  Syntax &amp; Examples</H2>
 FlushGetc does not require any parameters.<P>
<PRE>
	print	&quot;Enter a line of text:&quot;
	FlushGetc
	getsm
	print	&quot;You entered: &quot;
	puts
	free
	 .
	 .
	 .
</PRE>
<A NAME=HEADING1-251></A>
<HR>
<H1>13.9  rawGetc</H1>
 The rawGetc routine is one of the lowest level routines in the Standard input package.  All of the other routines that input data except GetcBIOS and GetcStdIn read their characters from the standard input device by calling rawGetc.  The rawGetc routine, in turn, transfers control to the current stdlib &quot;Standard Input Device.&quot;  It does this by jumping indirectly through the &quot;GetcAdrs&quot; pointer that contains the address of the current standard input device.  Normally, this pointer contains the address of the GetcStdIn routine (GetcStdIn reads a character from the DOS standard input device).  You can redirect the source of the standard library's standard input device by changing the address in this pointer variable.  See the &quot;SetInAdrs&quot; and &quot;GetInAdrs&quot; routines for more details.<P>
<A NAME=HEADING1-253></A>
<HR>
<H2>13.9.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-254></A>
<HR>
<H2>13.9.2  RawGetc Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>RawGetc Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>RawGetc<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 The RawGetc macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>RawGetc Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>RawGetc<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-259></A>
<HR>
<H2>13.9.3  Syntax &amp; Examples</H2>
<PRE>
	print	&quot;Enter Y or N:&quot;
	rawgetc
	tolower
	cmp	al, 'y'
	je	EnteredYes
	 .
	 .
	 .
</PRE>
<A NAME=HEADING1-268></A>
<HR>
<H1>13.10  rawGets, rawGetsCS, rawGetsStk,  rawGetsm</H1>
 These routines are comparable to the Gets, GetsStk, and Getsm routines except they read their data directly from the standard input device (rawGetc) rather than from the input Getc buffer.  See the Gets, GetsStk, and Getsm routines for more details.<P>
 These routines ignore any non-ASCII characters.  If you press a cursor control key or a function key, that key is not placed in the destination string.  Since the buffered input routines read data from the standard input device via calls to rawGets, this also means that you cannot read non-ASCII characters using buffered I/O routines like Getc, PeekC, Gets, etc.<P>
<A NAME=HEADING1-271></A>
<HR>
<H2>13.10.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-272></A>
<HR>
<H2>13.10.2  RawGets Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>RawGets Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>RawGets<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-<TD>X</TABLE>
<P>
 <P>
 The RawGets macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>RawGets Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>RawGets<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-277></A>
<HR>
<H2>13.10.3  Syntax &amp; Examples</H2>
<PRE>
Name	byte	256 dup (0)
	 .
	 .
	 .
	print	&quot;Enter your name:&quot;
	lesi	Name
	rawgets
	printf	&quot;Hello %s\n&quot;, Name
	 .
	 .
	 .
	print	&quot;Enter your name again:&quot;
	rawGetsCS
	dword	Name
	printf	&quot;Hi again, %s\n&quot;, Name
	 .
	 .
	 .
	print	&quot;Enter your name again:&quot;
	push	seg Name
	push	offset Name
	rawGetsStk
	printf	&quot;Hi again, %s\n&quot;, Name
	 .
	 .
	 .
	print	&quot;Enter your name yet a third time:&quot;
	rawgetsm
	print	&quot;Are you sure you're &quot;
	puts
	putc	'?'
	putcr
	free

	rawGets		;Stores string at ES:DI

	rawGets	bVar	;Stores string starting at location bVar

	rawGets	[wVar]	;Stores string at address pointed at by wVar.

	rawGets	[dVar]	;Stores string at far address in dVar.
</PRE>
<A NAME=HEADING1-319></A>
<HR>
<H1>13.11  GetcStdIn</H1>
 This routine reads a single character from the DOS standard input device.  By default, this is the routine that rawGetc (and therefore, all the other character input routines) calls in order to read a character from the standard input device.  GetcStdIn does no internal buffering of its own, hence it is a &quot;raw&quot; input routine (of course, DOS and/or BIOS may do some buffering, but that is outside the control of the stdlib).  GetcStdIn returns the character read in the AL register.<P>
 GetcStdIn begins by checking to see if it is reading data directly from some device (e.g., the keyboard) or from a file.  The behavior of the system changes somewhat if you are reading data from a file (via input redirection) rather than a device.  GetcStdIn processes the input stream differently so that any routines calling GetcStdIn (e.g., rawGetc) see a unified view of the system and don't have to do any special handling of their own.  One difference, for example, concerns end of line sequences.  GetcStdIn assumes that data coming from a hardware device terminates each line with a CR (but no corresponding LF);  it assumes that data coming from a file terminates each line with a CR/LF sequence.  GetcStdIn eats the line feed in a CR/LF sequence if reading data from a file.  It simply passes line feeds read from a device (like the keyboard).<P>
 GetcStdIn checks for device/file I/O errors and end of file (control-Z on a device, true end of file when reading from a file).  If a device or file I/O error occurs, GetcStdIn will raise the $FileIO exception if exceptions  are active.  Otherwise, it will set the carry flag and return the appropriate DOS error code in the AX register.  If end of file occurs, GetcStdIn will raise the $EndOfFile exception, if exceptions are active; otherwise it will return with the carry flag clear and AH=0.  If no error occurs, GetcStdIn returns with the carry flag clear, the ASCII code in AL, and AH=1.<P>
 GetcStdIn call DOS to read a character from the standard input device.  Therefore, it inherits all the properties of the DOS standard input device.  In particular, if the current input device is the keyboard and the user presses a non-ASCII key (e.g., a function or cursor control key), then GetcStdIn returns two characters: a zero byte followed by the scan code for that particular key.  GetcStdIn does not do any special handling on non-ASCII characters.  That is still the application program's responsibility to manage.<P>
<A NAME=HEADING1-324></A>
<HR>
<H2>13.11.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-325></A>
<HR>
<H2>13.11.2  GetcStdIn Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>GetcStdIn Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>GetcStdIn<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
 The GetcStdIn macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>GetcStdIn Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>GetcStdIn<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-329></A>
<HR>
<H2>13.11.3  Syntax &amp; Examples</H2>
 GetcStdIn does not require any parameters.<P>
<PRE>
                print   &quot;If inputing data from the keyboard, &quot;
                print   &quot;press control-Z to stop.&quot;,nl
                
GCLoop:         getcStdIn
                jc      IOError
                cmp     ah, 0
                je      EOFError
                cmp     al, 0
                je      NonASCIIChar
                print   &quot;You pressed: &quot;
                putc
                putcr
                jmp     GCLoop

NonASCIIChar:   GetcStdIn
                jc      IOError
                cmp     ah, 0
                je      EOFError
                print   &quot;You pressed a non-ASCII character whose &quot;
                print   &quot;scan code is &quot;
                puth
                putcr
                jmp     GCLoop
                
IOError:        print   &quot;I/O error #&quot;
                puti
                print   &quot; occured during read.&quot;,nl
                jmp     Done
                
EOFError:       print   &quot;End of file encountered.&quot;,nl
Done:

</PRE>
<A NAME=HEADING1-363></A>
<HR>
<H1>13.12  GetcBIOS</H1>
 GetcBIOS calls the PC's BIOS routines to directly read a character from the system keyboard (or from the system's keyboard typeahead buffer if there are any keys in that buffer).  GetcBIOS uses the same system interface as GetcStdIn except it will not raise any exceptions or return any error (it always returns with the carry clear and AH=1).  <P>
 Unlike the PC BIOS int 16h functions, GetcBIOS does not return the scan code in AH and a zero in AL if the user presses a non-ASCII character.  GetcBIOS preprocesses such keystrokes and returns the same two-character sequences that GetcStdIn returns. <P>
 Note that GetcBIOS does not check for end of file, therefore it always returns a one in the AH register.  If you press the control-Z key, GetcBIOS will return the ASCII code for control-Z.  Likewise, GetcBIOS does not handle control-C any differently than other keys.  It just returns the ASCII code for control-C (03).<P>
<A NAME=HEADING1-367></A>
<HR>
<H2>13.12.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-368></A>
<HR>
<H2>13.12.2  GetcBIOS Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>GetcBIOS Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>GetcBIOS<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-<TD>X</TABLE>
<P>
 The GetcBIOS macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>GetcBIOS Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>GetcBIOS<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-372></A>
<HR>
<H2>13.12.3  Syntax &amp; Examples</H2>
 GetcBIOS does not require any parameters.<P>
<PRE>
controlZ        =       26

                print   &quot;If inputing data from the keyboard, &quot;
                print   &quot;press control-Z to stop.&quot;,nl
                
GCLoop:         getcStdIn
                cmp     al, controlZ
                je      Done
                cmp     al, 0
                je      NonASCIIChar
                print   &quot;You pressed: &quot;
                putc
                putcr
                jmp     GCLoop

NonASCIIChar:   GetcStdIn
                print   &quot;You pressed a non-ASCII character whose &quot;
                print   &quot;scan code is &quot;
                puth
                putcr
                jmp     GCLoop
                
Done:
</PRE>
<A NAME=HEADING1-397></A>
<HR>
<H1>13.13  SetInAdrs, GetInAdrs</H1>
 The Standard Input package provides the ability to redirect the standard input device, independent of DOS' redirection capabilities.  All of the routines in the standard input package that read characters (except GetcStdIn and GetcBIOS) ultimately call the rawGetc routine to read characters from the standard input device.  The rawGetc routine jumps to an appropriate handler to actually read the character from the current input device;  this is usually the GetcStdIn function.  However, rawGetc transfers control to the handler by jumping to the function whose address appears in the internal GetcAdrs pointer variable.  By changing the value of this pointer, you can redirect the input to a different input device handler function.<P>
 Thet GetInAdrs and GetInAdrs (along with the PushInAdrs and PopInAdrs) functions provide you with the ability to maintain the GetcAdrs pointer.  GetInAdrs returns the current value of this (far) pointer in the ES:DI register pair.  This allows you to save the current value so you can restore it later after you are done redirecting the standard input.  The SetInAdrs copies the value in the ES:DI register pair to the GetcAdrs pointer.  Presumably, you would load the address of an appropriate input device handler into ES:DI before calling SetInAdrs.<P>
 An input device handler should read a single character from it associated device and return the ASCII code (or whatever code you want to use) in the AL register.    It should also return an error status in the carry flag (C=1 for error, C=0 for success).  If an error occurs, you can return a DOS error code in the AX register.   The character device handler should return the  EOF status in AH (AH=0 for end of file, AH=1 for not end of file).  Note that when returning end of file, you should clear the carry flag.<P>
 If exceptions are active, you can raise an appropriate exception when EOF or an input error occurs.  Your device handler should explicitly check to see if exceptions are active (using the GetXEnabled call) before raising any exceptions.<P>
 Input handlers must be far procedures and must preserve all registers except AX.<P>
<A NAME=HEADING1-403></A>
<HR>
<H2>13.13.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-404></A>
<HR>
<H2>13.13.2  GetInAdrs, SetInAdrs Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>GetInAdrs, SetInAdrs Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>GetInAdrs<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-<TD>-<TR>
<TD>SetInAdrs<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
 The GetInAdrs and SetInAdrs macros allow the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>GetInAdrs/SetInAdrs Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>GetInAdrs<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-<TR>
<TD>SetInAdrs<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-408></A>
<HR>
<H2>13.13.3  Syntax &amp; Examples</H2>
 The following is a typical device handler.  This particular device handler reads characters from the DOS standard input device without checking for end of file or control-C.<P>
<PRE>
DOSInput        proc    far
                mov     ah, 7           ;DOS char read w/o ^c chk
                int     21h
                mov     ah, 1           ;Cannot detect EOF.
                ret
DOSInput        endp

ASCIIOnly       proc    far
AOLoop:         GetcStdIn
                jc      Done            ;Bail if error.
                cmp     ah, 0
                je      Done            ;Bail if EOF.
                
                cmp     al, 0           ;Non-ASCII character?
                jne     Done
                GetcStdIn               ;Eat scan code
                jmp     AOLoop          ; and get the next char.
                
Done:           ret
ASCIIOnly       endp

</PRE>
 The following example demonstrates how to use the SetInAdrs and GetInAdrs functions to redirect the standard input device:<P>
<PRE>
GetcAdrsSave    dword   ?
                 .
                 .
                 .
                GetInAdrs
                mov     word ptr GetcAdrsSave, di
                mov     word ptr GetcAdrsSave+2, es
                
                lesi    DOSInput
                SetInAdrs
                 .
                 .      ;Input statements in this section
                 .      ; read their data using the DOSInput
                 .      ; character handler (no ctrl-C checking).
                 .
                lesi    ASCIIOnly
                SetInAdrs
                 .
                 .      ;Input statements in this section
                 .      ; read their data using the ASCIIOnly
                 .      ; character handler.  Therefore, the
                 .      ; input routines will only see ASCII
                 .      ; characters, all other keypresses
                 .      ; are ignored.
                 .
                les     di, GetcAdrsSave        ;Restore the address
                SetInAdrs                       ; of the original
                 .                              ; input handler.
                 .
                 .
</PRE>
<A NAME=HEADING1-462></A>
<HR>
<H1>13.14  PushInAdrs, PopInAdrs</H1>
 PushInAdrs and PopInAdrs are very similar to the GetInAdrs and SetInAdrs insofar as they let you manipulate the GetcAdrs pointer.  The primary difference between these routines and the Get/SetInAdrs routines is that the Push/PopInadrs routines preserve the current GetcAdrs on an internal stack rather than requiring you to explicitly save this pointer yourself.<P>
 The PushInAdrs function pushes the current GetcAdrs pointer onto an internal stack.  It then copies the pointer in ES:DI to GetcAdrs.  Therefore, PushInAdrs roughly corresonds to the SetInAdrs routine with the added benefit of automatically preserving the previous pointer value.  The internal GetcAdrs stack contains enough storage to hold 16 (nested) addresses you've pushed on the stack.  This should be far  more than any one program will ever need (most programs would need only one or two positions) assuming there isn't a programming error like forgetting to pop values you've pushed.  If a stack overflow occurs and exceptions are active, PushInAdrs will raise the $GetcStkErr exception.  If exceptions are not active, then PushInAdrs returns with the carry flag set and it does not change the current value of the GetcAdrs pointer nor does it change any value on the stack (in other words, the call is ignored).<P>
 The PopInAdrs pops an address off the internal stack and stores this address into the GetcAdrs pointer.  This restores GetcAdrs with the address of the previous character input device handler.  PopInAdrs returns with the carry flag clear if it sucessfully restored the GetcAdrs pointer.  If stack underflow occurs (i.e., you call PopInAdrs when there is no data on the internal stack), PopInAdrs will raise a $GetcStkErr exception if exceptions are active.  It will return with the carry flag set and store the address of the GetcStdIn routine into GetcAdrs if exceptions are not active.<P>
<A NAME=HEADING1-466></A>
<HR>
<H2>13.14.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-467></A>
<HR>
<H2>13.14.2  PushInAdrs, PopInAdrs Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>PushInAdrs, PopInAdrs Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>PushInAdrs<TD>X<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TR>
<TD>PopInAdrs<TD>X<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;</TABLE>
<P>
 The PushInAdrs and PopInAdrs macros allow the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>PushInAdrs/PopInAdrs Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>PushInAdrs<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-<TR>
<TD>PopInAdrs<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-471></A>
<HR>
<H2>13.14.3  Syntax &amp; Examples</H2>
 The following code sequence uses the character handlers developed for SetInAdrs and GetInAdrs.  Please see the example for those routines for more details.<P>
<PRE>
                 .
                 .
                 .
                lesi    DOSInput
                PushInAdrs
                 .
                 .      ;Input statements in this section
                 .      ; read their data using the DOSInput
                 .      ; character handler (no ctrl-C checking).
                 .
                lesi    ASCIIOnly
                SetInAdrs
                 .
                 .      ;Input statements in this section
                 .      ; read their data using the ASCIIOnly
                 .      ; character handler.  Therefore, the
                 .      ; input routines will only see ASCII
                 .      ; characters, all other keypresses
                 .      ; are ignored.
                 .
                PopInAdrs                       ;Restore the address
                 .                              ; of the original
                 .                              ; input handler.
                 .
</PRE>
<A NAME=HEADING1-497></A>
<HR>
<H1>13.15  ResetStdIn</H1>
 The ResetStdIn routine initializes the stdlib Standard Input Device.  It stores the address of the GetcStdIn routine into the GetcAdrs pointer and it initializes the internal Getc stack.  It also flushes any characters currently setting in the Standard Input internal buffer.<P>
<A NAME=HEADING1-499></A>
<HR>
<H2>13.15.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-500></A>
<HR>
<H2>13.15.2  ResetStdIn Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>ResetStdIn Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>ResetStdIn<TD>X<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;</TABLE>
<P>
 The ResetStdIn macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>ResetStdIn Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>ResetStdIn<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-504></A>
<HR>
<H2>13.15.3  Syntax &amp; Examples</H2>
 ResetStdIn requires no parameters.<P>
<PRE>
	.
	.
	.
	ResetStdIn
	.
	.	;Standard input behaves just as it did on program startup
	.	; at this point.
</PRE>
<A NAME=HEADING1-513></A>
<HR>
<H1>13.16  tstKbd</H1>
 The tstKbd routine checks to see if there is any kind of key in the PC's keyboard type ahead buffer.  This routine returns zero in AX if there are no keys available;  it returns one in AX if there is at least one keycode ready to be read.  This routine also compares AX against zero just before returning, so the zero flag also indicates whether a key is available (Z=1 for no key, Z=0 for key available).  <P>
 Note that many routines in the standard input package, including all buffered I/O routines, throw out any non-ASCII characters.  Therefore, although tstKbd might claim keystrokes are available, a call to one of these routines that throw away non-ASCII characters may have to wait until the user presses an actual ASCII character at the keyboard.  GetcBIOS, GetcStdIn and rawGetc (assuming GetcAdrs points at GetcStdIn or GetcBIOS) are the only routines in the standard input package that will return non-ASCII characters like function keys or cursor control keys.  Therefore,  you would typically call one of these three routines after testing the system status with a tstKbd call, assuming you did not want a delay if tstKbd returns true.  See the tstASCII function for additional details.<P>
<A NAME=HEADING1-516></A>
<HR>
<H2>13.16.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-517></A>
<HR>
<H2>13.16.2  TestKbd Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>TstKbd Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>TstKbd<TD>X<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;</TABLE>
<P>
 The TestKbd macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>TestKbd Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>TestKbd<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-521></A>
<HR>
<H2>13.16.3  Syntax &amp; Examples</H2>
 tstKbd requires no parameters.<P>
<PRE>
; The following loop continuously checks the keyboard to
; see if a key is available.  If not, it executes the
; &quot;Background&quot; procedure on each iteration of the loop.
;
; This allows background processing to commence as long
; as the user does not press a key on the keyboard.

TstLoop:        tstKbd
                jne     GotAKey
                call    Background
                jmp     TstLoop
                
GotAKey:        rawgetc            ;Read the key pressed from the user
                 .
                 .
                 .
</PRE>
<A NAME=HEADING1-539></A>
<HR>
<H1>13.17  tstInput</H1>
 The tstInput routine is very similar to the tstKbd routine.  The primary difference is that tstInput will only return one in AX if there are some ASCII characters currently in the system's type ahead buffer.  If there are no characters in the buffer, or if the characters in the buffer are all non-ASCII (i.e., function key and cursor control key) characters, tstInput will return zero in the AX register.<P>
<A NAME=HEADING1-541></A>
<HR>
<H2>13.17.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-542></A>
<HR>
<H2>13.17.2  TstInput Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>TstInput Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TH>M<TR>
<TD>TstInput<TD>X<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;</TABLE>
<P>
 The TestInput macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>TestInput Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>byteVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>TestInput<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-546></A>
<HR>
<H2>13.17.3  Syntax &amp; Examples</H2>
 tstInput requires no parameters.<P>
<PRE>
; The following loop continuously checks the keyboard to
; see if a key is available.  If not, it executes the
; &quot;Background&quot; procedure on each iteration of the loop.
;
; This allows background processing to commence as long
; as the user does not press a key on the keyboard.

TstLoop:        tstInput
                jne     GotAKey
                call    Background
                jmp     TstLoop
                
GotAKey:        gets            ;Read a line of text from the user.
                 .
                 .
                 .
</PRE>
<A NAME=HEADING1-564></A>
<HR>
<H1>13.18  Geth, GethCS, GethStk, Gethl</H1>
 Geth reads a 16-bit hexadecimal value from the standard input and returns its value in the AX register.  Gethl reads a 32-bit value from the standard input and returns its value in EAX.  They will skip any leading spaces before the value, as necessary.<P>
 If exceptions are enabled, these routines will raise an overflow exception if the value will not fit into 16 bits (Geth) or 32 bits (Gethl).  These routines will raise a $Conversion exception if there are any illegal characters in the number.  The regular expression that defines a legal hexadecimal value is:<P>
<PRE>
ws* [&quot;0&quot;-&quot;9&quot;,&quot;A&quot;-&quot;F&quot;,&quot;a&quot;-&quot;f&quot;] 
	[[&quot;0&quot;-&quot;9&quot;, &quot;A&quot;-&quot;F&quot;, &quot;a&quot;-&quot;f&quot;, &quot;_&quot;]* [&quot;0&quot;-&quot;9&quot;, &quot;A&quot;-&quot;F&quot;, &quot;a&quot;-&quot;f&quot;]]? 
		[ws | &quot;,&quot;]

</PRE>
 In English, this regular expression says that a hexadecimal value may begin with zero or more whitespace characters, followed by a single hexadecimal digit (0-0, A-F, a-f), followed by zero or more hexadecimal characters and underscores (although an underscore cannot end the value), followed by whitespace or a comma.<P>
 Other possible exceptions include $EndOfFile and $FileIO.  These exceptions, of course, assume that the standard input is redirected from a file. <P>
 If exceptions are not enabled, Geth and Gethl return the carry flag set if an error occurs.<P>
 If the hexadecimal value ends with the comma character, the Geth and Gethl routines will remove the comma from the standard input stream.  However, if the hexadecimal value ends with a whitespace character, Geth and Gethl will not remove the whitespace character from the standard input stream.<P>
<A NAME=HEADING1-575></A>
<HR>
<H2>13.18.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-576></A>
<HR>
<H2>13.18.2  Geth, Gethl Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Geth, Gethl Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Geth<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-<TR>
<TD>Gethl<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The Geth and Gethl macros allow the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Geth, Gethl Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Geth<TD>X<TD>word<TD>-<TD>X<TD>X<TD>-<TR>
<TD>Gethl<TD>X<TD>dword<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-581></A>
<HR>
<H2>13.18.3  Syntax &amp; Examples</H2>
 Standard calls to Geth, GethCS, GethStk, Gethl, GethlCS, and GethlStk:<P>
<PRE>
                cout    &quot;Enter a 16-bit hex value:&quot;
                geth
                cout    &quot;You entered: &quot;,ax,nl

                gethCS
                dword   wVar

                pshAdrs wVar
                gethStk


                cout    &quot;Enter a 32-bit hex value: &quot;
                gethl
                cout    &quot;You entered: &quot;,eax,nl

                getlhcs
                dword    dVar

                pshadrs  dVar
                getlhStk

</PRE>
<A NAME=HEADING1-604></A>
<HR>
<H1>13.19  Geti</H1>
 Geti reads a 16-bit signed integer value from the standard input and returns its value in AX.  This value must be in the range -32768..+32767.  The regular expression for signed integers is<P>
<PRE>
ws* [&quot;-&quot;]? [&quot;0&quot;-&quot;9&quot;] [[&quot;0&quot;-&quot;9&quot;,&quot;_&quot;]* [&quot;0&quot;-&quot;9&quot;]]? [ws | &quot;,&quot;]
</PRE>
 <P>
 In English, this means that a valid integer value can be preceeded by zero or more whitespace characters, followed by an optional minus sign, followed by at least one decimal digit, followed by zero or more decimal digits or underscores (although the number must end with a digit), followed by a comma or whitespace.<P>
 Geti can raise the following exceptions:<P>
<PRE>
$Conversion-		If the decimal string contains illegal characters.
$Overflow-		If the value is outside the range -32768..+32767.
$EndOfFile-		If end of file occurs while reading the input.
$FileIO-		If a file I/O error occurs while reading the input.
$Break-		If the user presses control-C while inputting the data.

</PRE>
 Geti will only raise an exception if exceptions are enabled.  It will return the carry flag set if an error occurs and exceptions are not active.<P>
<A NAME=HEADING1-617></A>
<HR>
<H2>13.19.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-618></A>
<HR>
<H2>13.19.2  Geti Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Geti Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Geti<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 The Geti macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Geti Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>wordVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Geti<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-622></A>
<HR>
<H2>13.19.3  Syntax &amp; Examples</H2>
 Standard calls to Geti, GetiCS, and GetiStk:<P>
<PRE>
                print   &quot;Enter an integer: &quot;
                geti
                print   &quot;You entered: &quot;
                puti
                putc

                getiCS
                dword   wVar

                pshadrs wVar
                getiStk

                geti     wVar
                geti     [wVar]
                geti     [dVar]
</PRE>
<A NAME=HEADING1-639></A>
<HR>
<H1>13.20  Getu</H1>
 Getu is identical to Geti except it inputs 16-bit unsigned values in the range 0..65535.  The regular expression is<P>
<PRE>
	ws* [&quot;0&quot;-&quot;9&quot;] [[&quot;0&quot;-&quot;9&quot;,&quot;_&quot;]* [&quot;0&quot;-&quot;9&quot;]]? [ws | &quot;,&quot;]

</PRE>
 See the description of Geti for more details about Getu.<P>
<A NAME=HEADING1-644></A>
<HR>
<H2>13.20.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-645></A>
<HR>
<H2>13.20.2  Getu Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Getu Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Getu<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The Getu macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Getu Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>wordVar<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Getu<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-650></A>
<HR>
<H2>13.20.3  Syntax &amp; Examples</H2>
 Standard calls to Getu, GetuCS, and GetuStk:<P>
<PRE>
                print   &quot;Enter an unsigned 16-bit integer: &quot;
                getu
                print   &quot;You entered: &quot;
                putu
                putcr

                getuCS
                dword   wVar

                pshadrs wVar
                getuStk

                getu     wVar
                getu     [wVar]
                getu     [dVar]
</PRE>
<A NAME=HEADING1-667></A>
<HR>
<H1>13.21  Getl</H1>
 Getl is identical to Geti except it reads 32-bit signed integers from the standard input and returns their value in the EAX register.  It raises an overflow exception if the value is outside the range -2147483648..+2147483647.  Otherwise, its behavoir is identical to Geti's.<P>
<A NAME=HEADING1-669></A>
<HR>
<H2>13.21.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-670></A>
<HR>
<H2>13.21.2  Getl Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Getl Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Getl<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The Getl macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Getl Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>dword Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Getl<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-675></A>
<HR>
<H2>13.21.3  Syntax &amp; Examples</H2>
 Getl, GetlCS, and GetlStk standard syntax:<P>
<PRE>
                print   &quot;Enter a signed 32-bit integer: &quot;
                getl
                print   &quot;You entered: &quot;
                putl
                putcr

                getlCS
                dword   dVar

                pshadrs dVar
                getlStk

                getl     dVar
                getl     [wVar]
                getl     [dVar]
</PRE>
<A NAME=HEADING1-692></A>
<HR>
<H1>13.22  Getul</H1>
 Getul is identical to Getu except it reads 32-bit unsigned integers from the standard input and returns their value in the EAX register.  It raises an overflow exception if the value is outside the range 0..4294967295.  Otherwise, its behavoir is identical to Getu's.<P>
<A NAME=HEADING1-694></A>
<HR>
<H2>13.22.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-695></A>
<HR>
<H2>13.22.2  Getul Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Getul Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Getul<TD>X<TD>X<TD>-<TD>X<TD>-<TD>-</TABLE>
<P>
 <P>
 The Getul macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Getul Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>dword Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Getul<TD>X<TD>X<TD>-<TD>X<TD>X<TD>-</TABLE>
<P>
<A NAME=HEADING1-700></A>
<HR>
<H2>13.22.3  Syntax &amp; Examples</H2>
 Standard syntax or the Getul, GetulCS, and GetulStk routines:<P>
<PRE>
                print   &quot;Enter a signed 32-bit unsigned integer: &quot;
                getul
                print   &quot;You entered: &quot;
                putul
                putcr

                getulCS
                dword   dVar

                pshadrs dVar
                getulStk

                getul     dVar
                getul     [wVar]
                getul     [dVar]

</PRE>
<A NAME=HEADING1-718></A>
<HR>
<H1>13.23  Getf</H1>
 Getf reads a floating point value from the standard input device and pushes the 80-bit result onto the FPU stack.  The floating point input value can appear in decimal or scientific notation.<P>
 Getf can raise the following exceptions:<P>
<PRE>
$Conversion-		If the decimal string contains illegal characters.
$Overflow-		If the value is outside the range 10**-4930..10**+4930
$EndOfFile-		If end of file occurs while reading the input.
$FileIO-		If a file I/O error occurs while reading the input.
$Break-		If the user presses control-C while inputting the data.

</PRE>
 Getf will only raise an exception if exceptions are enabled.  It will return the carry flag set if an error occurs and exceptions are not active.<P>
<A NAME=HEADING1-728></A>
<HR>
<H2>13.23.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-729></A>
<HR>
<H2>13.23.2  Getf Addressing Modes</H2>
 
<TABLE BORDER="1">
<CAPTION>Getul Addressing Modes</CAPTION>
<TH>Name<TH>Plain<TH>CS<TH>TOS<TH>Stk<TH>X<TH>CSi<TR>
<TD>Getul<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
 <P>
 The Getf macro allows the following operands:<P>
 
<TABLE BORDER="1">
<CAPTION>Getf Extended Syntax</CAPTION>
<TH>Name<TH>&nbsp;<TH>Var<TH>Num const<TH>[word Var]<TH>[dword Var]<TH>String Const<TR>
<TD>Getf<TD>X<TD>-<TD>-<TD>-<TD>-<TD>-</TABLE>
<P>
<A NAME=HEADING1-734></A>
<HR>
<H2>13.23.3  Syntax &amp; Examples</H2>
 Getf does not require any operands.<P>
<PRE>
                print   &quot;Enter a floating point value: &quot;
                getf
                print   &quot;You entered: &quot;
                mov     ax, 15
                pute
                putcr
</PRE>
<A NAME=HEADING1-742></A>
<HR>
<H1>13.24  Scanf, Scanff</H1>
 The stdlib Scanf routine provides a convient way to read different types of values from the standard input.  It uses a format string much like the PRINTF function to determine the types of values to input from the user.  The general form of the call is<P>
<PRE>
	scanf
	byte	&quot;format string&quot;, 0
	dword	&lt;Parameter list&gt;

</PRE>
 The format string consists of a list of format items.  A format item takes one of the following forms:<P>
<PRE>
%i	Input an integer
%^i	Input a *integer

%d	Input an integer
%^d	Input a *integer

%u	Input an unsigned integer
%^u	Input an unsigned *integer

%li	Input a 32-bit integer
%^li	Input a 32-bit *integer

%ld	Input a 32-bit integer
%^ld	Input a 32-bit *integer

%lu	Input a 32-bit unsigned integer
%^lu	Input a 32-bit unsigned *integer

%x	Input a 16-bit hex value
%^x	Input a 16-bit hex value and store it through a pointer

%lx	Input a 32-bit hex value
%^lx	Input a 32-bit hex value and store it through a pointer

%h	Input an 8-bit hex value
%^h	Input an 8-bit hex value and store it through a pointer

%c	Input a character
%^c	Input a ^character

%s	Input a string
%^s	Input a *string

%f	Input a float
%^f	Input a *float

%g	Input a double
%^g	Input a *double

</PRE>
 There must be at least one character following each format item in the scanf format string.  Typically, this would be a space or the string's zero terminating byte.  This character is know as the terminating character.  Scanf will allow this character (along with whitespace, a comma, or an end of line) to terminate any given input.  If the terminating character is a space or a zero byte, then Scanf only allows whitespace as a termination value.<P>
 For each format item in the format string, there must be a corresponding double word address following the format string.  Consider the following example:<P>
<PRE>
	scanf
	byte	&quot;%d %d %c&quot;,0
	dword	IntVar1, IntVar2, CharVar

</PRE>
 If a space appears in the format string, then Scanf will automatically skip all whitespace characters before inputting the next value.  This is the normal condition for numeric input (via calls to geti, getu, getf, etc).  Note, however, that Scanf extends this behavior to characters and strings as well.  In the example above, if the user had typed &quot;1  2  c&quot; then Scanf would have place the character &quot;c&quot; into CharVar rather than a space.  If you want to read the space as a character, you would need to call Getc.<P>
 The character immediately following a format item is special.  Scanf will allow the input value corresponding to that format item to end on that character even if that would normally be illegal.  For example, consider the following Scanf call:<P>
<PRE>
	scanf
	byte	&quot;%i: %i)&quot;,0
	dword	i,j

</PRE>
 If any other character appears in the format string, Scanf will remove that character from the standard input if it is the next character to be read from the standard input.  Otherwise, Scanf ignores that character in the format string.  Note that anywhere a space appears in the format string, Scanf will remove zero or more white space values  (rather than just one) from the standard input.  Consider the following example:<P>
<PRE>
	scanf
	byte	&quot; -%d (%d)&quot;,0
	dword	i,j

</PRE>
 In this example, the first character of the format string is a blank.  Therefore, Scanf will skip any number of whitespace characters that appear at the beginning of the line.  The &quot;-&quot; symbol tells Scanf to eat a minus sign, if that's the next character on the input.  Then Scanf reads an integer value into variable I.  Next, it skips any amount of whitespace and eats a possible open parenthesis.  Then it reads an integer variable into J and (possibly) eats a closing parenthesis.  Note that this code attempts to prevent the user from entering negative numbers for variable I (although if the user presses &quot;--1&quot; s/he would still succeed in entering a negative value).<P>
 If the &quot;^&quot; symbol appears between the &quot;%&quot; and the type specification then the corresponding parameter specifies the address of a pointer to the destination object rather than the address of the object itself.  This lets you read data into strings and other objects you've allocated on the heap or in a local activation record.  The pointer itself must be a static variable (typically in the data segment, though this is not required).<P>
 Scanf calls Gets to read strings.  Therefore, Scanf can read as many as 255 characters from the user when you specify string input.  You must ensure that your string variables have sufficient storage to hold any input.<P>
 Given Scanf's nature, it is difficult for Scanf to report an error on a specific input element.  Therefore, Scanf does not return with the carry denoting an error state.  However, Scanf will raise an appropriate exception if an error occurs.  If you enable exceptions you can trap errors that occur within Scanf.  <P>
 Since Scanff duplicates all the features found in Scanf (in addition to adding floating point support), you should never use both Scanff and Scanf in the same program;  doing so would waste memory.  MASM will generate a warning message if you call both functions in your program.<P>
<A NAME=HEADING1-810></A>
<HR>
<H2>13.24.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-811></A>
<HR>
<H2>13.24.2  Syntax &amp; Examples</H2>
 Unlike the CIN stream input operator (see the IOStream documentation), Scanf forces you to specify the type of the object you are reading.  The downside of this is that you have to know the types and carefully specify them (CIN handles this for you).  Furthermore, you cannot easily extend Scanf to read new types (at least, not without changing its source code).  There are two corresponding advantages to Scanf: first, you can read one type of variable using a different input format (e.g., read a hexadecimal value and shove it into an integer);  the second advantage is that you can use any variable, not just those you've declared in the VAR..ENDVAR section using the type declaration macros.  Other, less important, advantages include the ability to skip certain characters on input.<P>
<PRE>
                print   &quot;Enter an integer, a character, and a string:&quot;
                scanf
                byte    &quot;%d %c %s&quot;,0
                dword   IntVar, CharVar, StrVar
                
                printf  
                byte    &quot;You entered int=%d, char=%c, string=%s\n&quot;,0
                dword   IntVar, CharVar, StrVar
                
</PRE>
<A NAME=HEADING1-822></A>
<HR>
<H2>13.24.3  Alternate Syntax</H2>
 Scanf/Scanff supports an alternate syntax that allows you to include the format string and, optionally, the other parameters as operands to the Scanf/Scanff statement.  A typical call to Scanf using this syntax would take the form:<P>
<PRE>
	scanf	&quot;%d %c %s&quot;,IntVar,CharVar,StrVar

</PRE>
 You may also specify the dword parameters separately, as follows:<P>
<PRE>
	scanf	&quot;%d %c %s&quot;
	dword	IntVar, CharVar, StrVar
</PRE>
<A NAME=HEADING1-829></A>
<HR>
<H1>13.25  GetTermChar, SetTermChar</H1>
 Most of the numeric input routines terminate numeric input whenever they encounter a symbol that is not an appropriate digit or other allowable character within a number (e.g., &quot;_&quot;).  Legal numeric termination characters include whitespace, a comma, or the end of line.  Most other characters, if the function encounters them, will raise a conversion exception or return an error.  Occasionally, you may want to allow some other character as the termination value.  The standard library numeric input routines provide the ability to use one additional termination character.  Normally, this feature is disabled.  However, you can activate it using GetTermChar and SetTermChar.<P>
 GetTermChar returns in AL the current special termination character.  If this value is zero, then this feature is currently disabled.  You can use GetTermChar to preserve the current value if you need to change it for a short time period.<P>
 SetTermChar sets the special termination character to the value found in the AL register.<P>
<A NAME=HEADING1-833></A>
<HR>
<H2>13.25.1  Calling Conventions and Assertions</H2>
<A NAME=HEADING1-834></A>
<HR>
<H2>13.25.2  Syntax &amp; Examples</H2>
<PRE>
SaveChar        byte    ?
                 .
                 .
                 .
                GetTermChar             ;Save current value
                mov     SaveChar, al
                mov     al, &quot;:&quot;         ;Allow #s to end with
                SetTermChar             ; a &quot;:&quot; character.
                 .
                 .                      ;Numeric input routines
                 .                      ; that allow values to
                 .                      ; end with a &quot;:&quot;
                 .
                mov     al, SaveChar    ;Restore the special
                SetTermChar             ; termination char to
                                        ; its previous value.

</PRE>
</BODY>
</HTML> 