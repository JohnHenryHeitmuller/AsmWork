<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE> </TITLE>
</HEAD>
<BODY>
<A NAME=HEADING1></A>
UCR Standard Library -- Constants<P>
<HR>
<!-- TOC --><DL>
<DT><A HREF="consts_1.htm#HEADING1-1"><B></B>UCR StdLib v2: Constants</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-3"><B>4.1	</B> - Interface</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-14"><B>4.2	</B> - Generic Interface</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-41"><B>4.3	</B> - Simple Constants and Text Equates</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-60"><B>4.4	</B> - Macros for Common Operations.</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-62"><B>4.4.1	</B> - DOS</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-76"><B>4.4.2	</B> - ExitPgm</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-87"><B>4.4.3	</B> - LESI, LFSI, LFSI</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-119"><B>4.4.4	</B> - XFSGS, FSES, and ESFS</A>
<DD>
<DT><A HREF="consts_1.htm#HEADING1-148"><B>4.4.5	</B> - Pshadrs</A>
<DD>
</DL>

<A NAME=HEADING1-0></A>
<H1></H1>
<HR>
<A NAME=HEADING1-1></A>
<H1> UCR StdLib v2: Constants</H1>
 The UCR Standard Library (stdlib) contains a large number of constants and macros that are of interest to assembly language programmers.  This section describes these values.<P>
<A NAME=HEADING1-3></A>
<HR>
<H1>4.1  Interface</H1>
 To access the routines in the conversions package, your assembly language module must include the file &quot;consts.a&quot; during assembly.  You can accomplish this with either of the following include statements in your assembly code:<P>
<PRE>

        include consts.a
or
        include ucrlib.a

</PRE>
 Note that the &quot;ucrlib.a&quot; include file automatically includes all include files associated with the UCR Standard Library.  Also note that many other include files automatically include the &quot;consts.a&quot; file, so it might not be necessary to include &quot;consts.a&quot; in your main program if you are using other modules in the standard library.  Note that the &quot;consts.a&quot; file also includes the &quot;macros.a&quot; file.  Many of the symbols this document discusses actually appear in the &quot;macros.a&quot; file. <P>
 The consts.a include file defines some private symbols.  The UCR Standard Library prefaces all &quot;private&quot; names with a dollar sign (&quot;$&quot;).  You should not use any symbol in this package that begins with this symbol.  To avoid name conflicts, you should not define any symbols in your programs that begin with a dollar sign (&quot;$&quot;).  Note that future versions of the stdlib (that remain compatible with this release)  may change &quot;private&quot; names.  To remain compatible with future releases, you must not refer to these &quot;private&quot; names within your programs unless otherwise advised that this is okay.<P>
 Source code appearing in this chapter is current as of Version Two, Release 40.   There may be minor changes between this source code and the current release.<P>
 <P>
<A NAME=HEADING1-14></A>
<HR>
<H1>4.2  Generic Interface</H1>
 Many of the standard library routines use a common generic programmer's interface.  Such routines let you pass parameters to them in several different locations.  Common examples include in the registers, by value in the code stream (CSi), by reference in the code stream (CS), by value on the top of stack (TOS), and by reference on the top of stack (Stk).  Typically, there are separate invocation macros defined for each of these variants, e.g.,<P>
<PRE>

        IsAlNum                 ;Passed in AL register.

        IsAlNumCS
        dword   chrPtr          ;Passed by reference in code stream.

        push    'a'             ;Passed by value on the stack.
        IsAlNumTOS

        push    seg chrVar      ;Passed by reference on the stack.
        push    offset chrVar
        IsAlNumStk

</PRE>
 Note that you will rarely find actual routines that pass their parameters by value in the code stream using the &quot;CSi&quot; suffix.  The reason this is so is because most such routines use different, more descriptive names.  For example, &quot;PutsCSi&quot; goes by the name &quot;Print&quot;.<P>
 In addition to the above forms there are two other suffixes generally applied to stdlib routine names: &quot;m&quot; and &quot;x&quot;.  The &quot;m&quot; suffix stands for &quot;malloc&quot;.  Routines with the &quot;m&quot; suffix typically generate a string result and malloc storage for the string on the heap, returning a pointer to this string in the ES:DI register pair.  The routines with an &quot;x&quot; suffix also process strings.  Most stdlib routines preserve the value of the ES:DI registers when processing strings; typically, they leave the ES:DI register pair pointing at the start of the string.  The routines with an &quot;x&quot; suffix do not preserve ES:DI, they generally leave ES:DI pointing at the zero byte of the string they processed or generated.<P>
 To make it easier to use all these different variants, the standard library typically defines a macro for each routine that lets you specify various operands using stdlib &quot;addressing modes.&quot;  The allowable addressing modes vary by routines, but they typically take one of the following forms:<P>
<PRE>

        name            ;If operand field is blank, use &quot;plain&quot; version.
        name    var     ;Generally passes address of var in code stream (CS).
        name    const   ;Pushes const onto TOS and uses nameTOS routine.
        name    [wvar]  ;Pushes DS followed by value of wVar variable
                        ; (assumed to be a word) and calls nameSTK
        name    [dVar]  ;Pushes dword value of dVar onto stk, calls nameStk.

</PRE>
 Since not all of these &quot;addressing modes&quot; are applicable to all instructions, and some instructions allow different sets of operands (including multiple operands), there are lots of special cases.  Such cases are noted after the explaination for each particular routine.<P>
<A NAME=HEADING1-41></A>
<HR>
<H1>4.3  Simple Constants and Text Equates</H1>
 The Standard Library provides several simple numeric and textual equates for some commonly used values.  The pertinent equates are:<P>
<PRE>

NULL    =       0
bell    =       07h
bs      =       08h
tab     =       09h
lf      =       0ah
cr      =       0dh
nl      textequ &lt;cr,lf&gt;

</PRE>
 Most of these are relatively straight-forward, only the last equate deserves any comment.  The &quot;nl&quot; (new line) equate expands to the two-character sequence carriage return/line feed.  You can use this equate anywhere it would be legal to put the two symbols &quot;cr&quot; and &quot;lf&quot; together (separated by a comma).  For example, you could legally place this symbol in the operand field of a BYTE directive.  However, the &quot;nl&quot; symbol is <I>not</I> legal in many places. Be aware of this problem.<P>
 Some additional text equates you may find useful are also defined in the consts.a and macros.a files:<P>
<PRE>

byp     textequ &lt;byte ptr&gt;
wp      textequ &lt;word ptr&gt;
dp      textequ &lt;dword ptr&gt;

</PRE>
 These symbols save you the expense of typing <B>byte ptr</B>, <B>word ptr</B>, or <B>dword ptr</B> when overriding a symbol's type.  Note that &quot;bp&quot; is a reserved word (the BP register) which is why the textequates above use BYP for the override symbol.<P>
<A NAME=HEADING1-60></A>
<HR>
<H1>4.4  Macros for Common Operations.</H1>
 The UCR Standard Library &quot;consts.a&quot; file supplies  macros for certain common operations.  The following sections describe the purpose of these macros and their calling sequences.<P>
<A NAME=HEADING1-62></A>
<HR>
<H2>4.4.1  DOS</H2>
 The DOS macro calls MS-DOS using the INT 21h instruction.  Without any operands, this instruction simply emits an INT 21h instruction.  If you supply a single operand, the DOS macro emits an instruction that loads the AH register with the value of this operand.  The (as of 10/96) definition for this macro is<P>
 <P>
<PRE>
DOS             macro   opcode
                ifnb    opcode
                mov     ah, opcode
                endif
                int     21h
                endm

</PRE>
 Sample use of this macro:<P>
 <P>
<PRE>
                mov     al, 0   ;No error pgm return code.
                dos     4ch     ;Terminates program execution.
</PRE>
<A NAME=HEADING1-76></A>
<HR>
<H2>4.4.2  ExitPgm</H2>
 The ExitPgm macro emits the necessary instructions that immediately terminate program execution and return control to the current DOS shell.  Note that ExitPgm expects a system return code in the AL register.  This should be zero if the program ran correctly. The ExitPgm macro uses function 4ch of the INT 21h call to do the deed.  The (10/96) definition for ExitPgm is<P>
<PRE>

ExitPgm         macro
                mov     ah, 4ch
                int     21h
                endm

</PRE>
 Sample usage:<P>
<PRE>
                mov     al, 2   ;Return error code 2.
                ExitPgm
</PRE>
<A NAME=HEADING1-87></A>
<HR>
<H2>4.4.3  LESI, LFSI, LFSI</H2>
 The 80x86 chips do not provide an instruction that lets you load the segmented address of a memory location into a segment:register pair.  True, the LDS, LES, LFS, LGS, and LSS instructions let you load a pointer into a segment:register pair, but they do not let you directly load an address into these register pairs (i.e., the LDS, LES, etc. instructions behave like <B>mov</B>, not <B>lea</B>).  Since the Standard Library uses far pointers, and loading the address of an object into a segment:register pair is a common operation, the Standard Library provides several macros that let you load the address of an object into ES:DI, FS:SI, and GS:BX.<P>
<PRE>
lesi            macro   adrs
                mov     di, seg adrs
                mov     es, di
                mov     di, offset adrs
                endm

lfsi            macro   adrs
                mov     si, seg adrs
                mov     fs, si
                mov     si, offset adrs
                endm

lgsi            macro
                mov     bx, seg adrs
                mov     gs, bx
                mov     bx, offset adrs
                endm
</PRE>
 <P>
 <P>
 Samples:<P>
<PRE>

i               word    -10
Name            byte    &quot;c:\filename.txt&quot;,0
                 .
                 .
                 .
                lesi    i       ;Loads ES:DI with the address
                                ; of the &quot;i&quot; variable.
                lfsi    Name    ;Loads FS:SI with the address
                                ; of the &quot;Name&quot; variable.
</PRE>
<A NAME=HEADING1-119></A>
<HR>
<H2>4.4.4  XFSGS, FSES, and ESFS</H2>
 Although the Standard Library's routines were designed to require as little &quot;glue code&quot; as necessary between calls, there are a few instances where you will find that the output from one function winds up in the wrong register pair for use as input to another function.  To help with this problem, the Standard Library provides several macros that let you exchange the data in a set of segment:register pairs and move the data from one register pair to another.<P>
 The xfsgs routine exchanges the data between the FS:SI and GS:DI register pairs.  The code for this macro is<P>
<PRE>

xfsgs           macro
                push    fs
                push    gs
                pop     fs
                pop     gs
                xchg    si, di
                endm

</PRE>
 The fses macro copies the data from the ES:DI register pair to the FS:SI register pair.  The code for this macro is<P>
<PRE>

fses            macro
                mov     si, es
                mov     fs, si
                mov     si, di
                endm

</PRE>
 The esfs macro copies the data from the FS:SI to the ES:DI register pair.  The code for this macro is<P>
<PRE>

esfs            macro
                mov     di, fs
                mov     es, di
                mov     di, si
                endm

</PRE>
 If you need other register move or exchange instructions, it is easy enough (of course) to write your own macros to accomplish this.<P>
<A NAME=HEADING1-148></A>
<HR>
<H2>4.4.5  Pshadrs</H2>
 Certain Standard Library calls expect the far address of an object on the stack.  The pshadrs macro pushes the far address of a symbol onto the stack (segment portion first, offset second).  This macro requires a single operand that must be the name of a variable or function.<P>
<PRE>

pshadrs         macro   object
                push    seg object
                push    offset object
                endm

</PRE>
 Example of usage:<P>
<PRE>

                pshadrs i
                putistk         ;Expects address on TOS.
</PRE>
 <P>
</BODY>
</HTML> 