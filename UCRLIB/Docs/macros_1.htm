<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE> </TITLE>
</HEAD>
<BODY>
<A NAME=HEADING1></A>
Stdlib Macros<P>
<HR>
<!-- TOC --><DL>
<DT><A HREF="macros_1.htm#HEADING1-1"><B></B>UCR StdLib2: Macros</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-5"><B>2.1	</B> - The MACROS.A File</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-7"><B>2.1.1	</B> - The IsConst Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-45"><B>2.1.2	</B> - The IsNumConst Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-60"><B>2.1.3	</B> - The IsStrConst Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-93"><B>2.1.4	</B> - The IsReg Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-112"><B>2.1.5	</B> - The IsVar Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-129"><B>2.1.6	</B> - The IsByte, IsWord, and IsDWord Macros</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-154"><B>2.1.7	</B> - The IsWordPtr and IsDWordPtr Macros</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-197"><B>2.1.8	</B> - The IsReg8 Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-243"><B>2.1.9	</B> - The pReg8 Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-297"><B>2.1.10	</B> - The IsReg16 Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-339"><B>2.1.11	</B> - The IsReg32 Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-381"><B>2.1.12	</B> - The $Push Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-405"><B>2.1.13	</B> - The $Pop Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-437"><B>2.1.14	</B> - The $Peek Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-461"><B>2.1.15	</B> - The Xtrn Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-485"><B>2.1.16	</B> - The bCSStkTOS Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-593"><B>2.1.17	</B> - The bCSStk Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-641"><B>2.1.18	</B> - The wCSStkTOS Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-750"><B>2.1.19	</B> - The wCSStk Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-819"><B>2.1.20	</B> - The LCSStkTOS Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-921"><B>2.1.21	</B> - The LCSSTK Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-981"><B>2.1.22	</B> - The sbCSStkTOS Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-1134"><B>2.1.23	</B> - The swCSStkTOS Macro</A>
<DD>
<DT><A HREF="macros_1.htm#HEADING1-1209"><B>2.1.24	</B> - The sdCSStkTOS Macro</A>
<DD>
</DL>

<A NAME=HEADING1-0></A>
<H1></H1>
<HR>
<A NAME=HEADING1-1></A>
<H1> UCR StdLib2: Macros</H1>
 As a general rule, one does not &quot;call&quot; standard library routines directly.  Instead, the library includes a set of macros that simplify calling the various routines.  Some of these macros do little more than directly call the routine (allowing you to simply specify the routine name rather than have to use the call instruction).  Other macros are quite sophisticated and let you use a high level language syntax to invoke various stdlib routines.<P>
 <P>
 MASM provides some terrific macro facilities that let you accomplish some amazing things.  Unfortunately, accomplishing something and understanding how it was accomplished are two different things.  Although MASM provides the capability, figuring out how to take advantage of it, and working around the bugs in MASM, can produce some incomprehensible code.  The macros that support the UCR Standard Library certainly border on incomprehensible, if they do not cross over into that territory.  The purpose of this chapter is to help make some sense of these macros.<P>
<A NAME=HEADING1-5></A>
<HR>
<H2>2.1  The MACROS.A File</H2>
 The macros.a file contains several useful macros used by the individual include files.  The following subsections describe each of the individual macros in this file.<P>
<A NAME=HEADING1-7></A>
<HR>
<H2>2.1.1  The IsConst Macro</H2>
 There is often the need to determine if a macro parameter is a literal constant.  The IsConst macro function handles this chore.  MASM's OPATTR function seems to supply this capability, but it has one glaring problem - it only recognizes numeric constants, it does not handle string constants.  IsConst handles this by first checking an operand to see if it is a string constant (i.e., it begins with either a quote or an apostrophe).  If the operand is not a string constant, then IsConst uses OPATTR to determine if it is a numeric constant.<P>
 <P>
 This macro function returns true (all bits set) if the specified operand is a literal constant.  It returns false (0) if it is not a literal constant.<P>
 <P>
 Checking for a string constant is rather difficult with MASM.  I couldn't find an easy way to compare the first character of an operand against a quote or apostrophe.  I did discover a truly disgusting way to do this; I would appreciate a better solution if somebody can discover something I've missed (that is reasonable compatible with all versions of MASM 6.x).<P>
 <P>
 My solution was to build the text constant &lt;' '&gt; or &lt;&quot; &quot;&gt; by concatenating the first character of the operand with a space followed by the first character again.  The following expression does this:<P>
 <P>
 @catstr(@substr(&lt;Operand&gt;,1,1),&lt; &gt;,@substr(&lt;Operand&gt;,1,1))<P>
 <P>
 I then use the IFIDN (if identical) statement to compare this result against &lt;' '&gt; and &lt;&quot; &quot;&gt; for equality.  If the substring above matches either of these, I assume we've got a string literal constant.  If the substring I've built doesn't match either of these, I use OPATTR to see if we've got a numeric constant.<P>
 <P>
 <P>
<PRE>
;IsConst-       Checks an operand to see if it is a constant (numeric or string).
;               This function returns true (0FFh) if the operand is a constant,
;               it returns false (0) otherwise.  You would normally use it with
;               the &quot;if&quot; directive.

IsConst         macro   Operand

;; Assume if we see a quote or an apostrophe that this is a string constant
;; operand.  The funny syntax below is necessary because MASM doesn't handle
;; stuff like &lt;'&gt; or &lt;&quot;&gt; too well.

%               ifidn   &lt;@catstr(@substr(&lt;Operand&gt;,1,1),&lt; &gt;,@substr(&lt;Operand&gt;,1,1))&gt;, &lt;' '&gt;
                exitm   &lt;-1&gt;
                endif

%               ifidn   &lt;@catstr(@substr(&lt;Operand&gt;,1,1),&lt; &gt;,@substr(&lt;Operand&gt;,1,1))&gt;, &lt;&quot; &quot;&gt;
                exitm   &lt;-1&gt;
                endif

;; If not quote or apostrophe, check it out with OPATTR.

                exitm   &lt;(((OPATTR Operand) and 1100b) eq 0100b)&gt;
                endm

</PRE>
<A NAME=HEADING1-45></A>
<HR>
<H2>2.1.2  The IsNumConst Macro</H2>
 The IsNumConst macro is simply a wrapper around the OPATTR function.  IsNumConst is much easier to read than the resulting call to OPATTR (see the implementation below).  IsNumConst returns all one bits (-1) if the operand is a numeric literal constant.  It returns zero if the operand is not a numeric literal constant.  Note that IsNumConst returns false for character and string constants.<P>
 <P>
 <P>
<PRE>
;IsNumConst-    Checks an operand to see if it is a numeric constant.
;               This function returns true (0FFh) if the operand is a constant,
;               it returns false (0) otherwise.  You would normally use it with
;               the &quot;if&quot; directive.

IsNumConst      macro   Operand

;; Check it out with OPATTR.

                exitm   &lt;(((OPATTR Operand) and 1100b) eq 0100b)&gt;
                endm
</PRE>
<A NAME=HEADING1-60></A>
<HR>
<H2>2.1.3  The IsStrConst Macro</H2>
 The IsStrConst macro checks its operand to see if it is a string constant.  See the description of the IsConst macro earlier for a blow-by-blow description of how this macro works.  IsStrConst returns true (all one bits, or -1) if the operand is a string constant, it returns false (0) if it is not a string constant.<P>
 <P>
<PRE>
;IsStrConst-    Checks an operand to see if it is a strong constant.
;               This function returns true (0FFh) if the operand is a constant,
;               it returns false (0) otherwise.  You would normally use it with
;               the &quot;if&quot; directive.

IsStrConst      macro   Operand

;; Assume if we see a quote or an apostrophe that this is a string constant
;; operand.  The funny syntax below is necessary because MASM doesn't handle
;; stuff like &lt;'&gt; or &lt;&quot;&gt; too well.

%               ifidn   &lt;@catstr(@substr(&lt;Operand&gt;,1,1), \
                                 &lt; &gt;, \
                                 @substr(&lt;Operand&gt;,1,1))&gt;, \
                        &lt;' '&gt;
                exitm   &lt;-1&gt;
                endif

%               ifidn   &lt;@catstr(@substr(&lt;Operand&gt;,1,1), \
                                 &lt; &gt;, \
                                 @substr(&lt;Operand&gt;,1,1))&gt;, \
                        &lt;&quot; &quot;&gt;
                exitm   &lt;-1&gt;
                endif

;; If not quote or apostrophe, it's not a string constant.

                exitm   &lt;0&gt;
                endm

</PRE>
<A NAME=HEADING1-93></A>
<HR>
<H2>2.1.4  The IsReg Macro</H2>
 The IsReg macro checks its operand to see if it is an 80x86 register.  Unlike the previous macros, this particular function does not return true or false.  Instead, it returns the operand if it is an 80x86 register, it return a blank text field if the operand is not an 80x86 register.  You can use the IFB (if blank) directive to test an operand to see if it is a register.  By returning the register name in this fashion, the IsReg macro is useful in a few situations (e.g., the operand field of various instructions) where it wouldn't be if it only returned true or false.<P>
 <P>
 This macro is a wrapper around the MASM OPATTR function to make the test for a register more readable.<P>
 <P>
<PRE>
;IsReg-         Checks to see if an operand is a register.
;               This function returns the operand as a textual value if
;               it is a register.  It returns the empty string (blank)
;               if the operand is not a register.  You would normally
;               use this function in an &quot;ifb&quot; directive.

IsReg           macro   Operand
                if      (((OPATTR Operand) and 10000b) eq 10000b)
                exitm   &lt;Operand&gt;
                else
                exitm   &lt;&gt;
                endif
                endm

</PRE>
<A NAME=HEADING1-112></A>
<HR>
<H2>2.1.5  The IsVar Macro</H2>
 The IsVar macro is very similar to the IsReg macro except, of course, it tests for a variable name rather than a register.  Otherwise, its usage is the same.  Like IsReg, IsVar is simply a wrapper around the OPATTR function to make programs easier to read.<P>
<PRE>

;IsVar-         Checks an operand to see if it is a variable.
;               This function returns the operand as a textual value if
;               it is a variable.  It returns the empty string (blank)
;               if the operand is not a variable.  You would normally
;               use this function in an &quot;ifb&quot; directive.

IsVar           macro   Operand
                if      (((OPATTR Operand) and 1010b) eq 1010b)
                exitm   &lt;Operand&gt;
                else
                exitm   &lt;&gt;
                endif
                endm

</PRE>
<A NAME=HEADING1-129></A>
<HR>
<H2>2.1.6  The IsByte, IsWord, and IsDWord Macros</H2>
 These three macros test their operand and return true or false depending on the size of the operand (byte, word, or dword, respectively).  Typically, one would apply these functions to a variable to determine its size.  Like many of the macros in this package, these macros are really wrappers around OPATTR in order to produce a more readable program.<P>
 <P>
 These functions return true (all bits set, or -1) if the specified operand is a variable of the specified type; they return false (0) otherwise.  One would normally use them as the operand of an IF directive.<P>
 <P>
<PRE>
; IsByte,
; IsWord,
; IsDword-      Tests its operand to see if it is a variable of the specific 
;               object size.

IsByte          macro   Operand
                exitm   &lt;((type Operand) eq 1) and \
                         (((OPATTR Operand) and 1010b) eq 1010b)&gt;
                endm

IsWord          macro   Operand
                exitm   &lt;((type Operand) eq 2) and \
                         (((OPATTR Operand) and 1010b) eq 1010b)&gt;
                endm

IsDword         macro   Operand
                exitm   &lt;((type Operand) eq 4) and \
                         (((OPATTR Operand) and 1010b) eq 1010b)&gt;
                endm

</PRE>
<A NAME=HEADING1-154></A>
<HR>
<H2>2.1.7  The IsWordPtr and IsDWordPtr Macros</H2>
 The IsWordPtr and IsDWordPtr macros check for a word and dword variable (respectively) surrounded by square brackets.  These two functions return a blank text object if the specified operand is not a word pointer or a dword pointer.  They return the object inside the square brackets if it is a word or dword variable.<P>
 <P>
 These two macros begin by checking to see if the &quot;[&quot; and &quot;]&quot; characters surround the operand.  After verifying this, these macros call the IsWord or IsDWord macros, passing in the characters between the &quot;[&quot; and &quot;]&quot; to determine if we've got word pointer or dword pointer syntax.  If this is the case, these macros return the substring between the &quot;[&quot; and &quot;]&quot; characters (otherwise these functions return an empty string).<P>
 <P>
<PRE>
; IsWordPtr-    Checks the operand to see if it is a word variable
;               surrounded by square brackets.
;
;               This function returns the operand minus the square brackets
;               if it is indeed a word ptr operand.  It returns blank
;               otherwise.  You would normally use this function in an
;               &quot;ifb&quot; directive or in the operand field of an instruction.

IsWordPtr       macro   Operand
%               ifidn   &lt;@substr(&lt;Operand&gt;,1,1)&gt;, &lt;[&gt;
%               ifidn   &lt;@substr(&lt;Operand&gt;,@SizeStr(&lt;Operand&gt;),1)&gt;, &lt;]&gt;
%               if      IsWord(&lt;@substr(&lt;Operand&gt;,2,@SizeStr(&lt;Operand&gt;)-2)&gt;)
%               exitm   &lt;@substr(&lt;Operand&gt;,2,@SizeStr(&lt;Operand&gt;)-2)&gt;
                endif
                endif
                endif
                exitm   &lt;&gt;
                endm

; IsDwordPtr-   Checks the operand to see if it is a dword variable
;               surrounded by square brackets.
;
;               This function returns the operand minus the square brackets
;               if it is indeed a dword ptr operand.  It returns blank
;               otherwise.  You would normally use this function in an
;               &quot;ifb&quot; directive or in the operand field of an instruction.

IsDwordPtr      macro   Operand
%               ifidn   &lt;@substr(&lt;Operand&gt;,1,1)&gt;, &lt;[&gt;
%               ifidn   &lt;@substr(&lt;Operand&gt;,@SizeStr(Operand),1)&gt;, &lt;]&gt;
%               if      IsDword(@substr(&lt;Operand&gt;,2,@SizeStr(&lt;Operand&gt;)-2))
%               exitm   &lt;@substr(&lt;Operand&gt;,2,@SizeStr(&lt;Operand&gt;)-2)&gt;
                endif
                endif
                endif
                exitm   &lt;&gt;
                endm

</PRE>
<A NAME=HEADING1-197></A>
<HR>
<H2>2.1.8  The IsReg8 Macro</H2>
 This function checks the operand to see if it is a valid eight-bit 80x86 register.  If so, this macro returns that register as the result, otherwise it returns an empty string as the result.  One would normally use this macro as the operand of an IFB directive, or in the operand field of some other instruction requiring an eight-bit register.<P>
 <P>
 The implementation of this macro is fairly straight-forward.  It simply compares its operand against the eight eight-bit register names (ignoring case) and returns the corresponding register as the result if a match occurs.<P>
 <P>
<PRE>
; IsReg8-       Checks the parameter to see if it corresponds to a
;               valid eight-bit 80x86 register.  It returns that
;               register as an operand if it is a valid 8-bit reg.
;               It returns blank otherwise.

IsReg8          macro   reg8
                ifidni  &lt;reg8&gt;, &lt;al&gt;
                exitm   &lt;al&gt;
                endif

                ifidni  &lt;reg8&gt;, &lt;bl&gt;
                exitm   &lt;bl&gt;
                endif

                ifidni  &lt;reg8&gt;, &lt;cl&gt;
                exitm   &lt;cl&gt;
                endif

                ifidni  &lt;reg8&gt;, &lt;dl&gt;
                exitm   &lt;dl&gt;
                endif

                ifidni  &lt;reg8&gt;, &lt;ah&gt;
                exitm   &lt;ah&gt;
                endif

                ifidni  &lt;reg8&gt;, &lt;bh&gt;
                exitm   &lt;bh&gt;
                endif

                ifidni  &lt;reg8&gt;, &lt;ch&gt;
                exitm   &lt;ch&gt;
                endif

                ifidni  &lt;reg8&gt;, &lt;dh&gt;
                exitm   &lt;dh&gt;
                endif

                exitm   &lt;&gt;      ;; Not a valid eight-bit register.
                endm

</PRE>
<A NAME=HEADING1-243></A>
<HR>
<H2>2.1.9  The pReg8 Macro</H2>
 The pReg8 macro checks its operand to see if it is one of the eight-bit registers.  If so, this function pushes that register onto the stack.  Since the 80x86 doesn't allow eight-bit push operations, this macro actually pushes the 16-bit register that contains the specified eight-bit register.  pReg8 always pushes the specified value as the L.O. byte.  Therefore, it will execute a pair of XCHG instructions around the push instruction if you specify one of AH, BH,CH, or DH.  Note that pReg8 will always correct this change after pushing the register onto the stack so the original eight-bit register pairs will be unchanged.  If the specified register is not an eight-bit register, this macro does nothing.<P>
 <P>
 Note that this macro is a true macro, not a macro function.  It does not return any value(s) to test with a conditional directive.<P>
 <P>
<PRE>
; pReg8-        If the specified operand is an eight-bit register,
;               this macro will push it onto the stack (it actually
;               pushes 16 bits, the specified value occupies the
;               L.O. byte of the value pushed).

pReg8           macro   Operand1

                ifidni  &lt;Operand1&gt;, &lt;al&gt;
                push    ax
                endif

                ifidni  &lt;Operand1&gt;, &lt;bl&gt;
                push    bx
                endif

                ifidni  &lt;Operand1&gt;, &lt;cl&gt;
                push    cx
                endif

                ifidni  &lt;Operand1&gt;, &lt;dl&gt;
                push    dx
                endif

                ifidni  &lt;Operand1&gt;, &lt;ah&gt;
                xchg    al, ah
                push    ax
                xchg    al, ah
                endif

                ifidni  &lt;Operand1&gt;, &lt;bh&gt;
                xchg    bl, bh
                push    bx
                xchg    bl, bh
                endif

                ifidni  &lt;Operand1&gt;, &lt;ch&gt;
                xchg    cl, ch
                push    cx
                xchg    cl, ch
                endif

                ifidni  &lt;Operand1&gt;, &lt;dh&gt;
                xchg    dl, dh
                push    dx
                xchg    dl, dh
                endif

                endm

</PRE>
<A NAME=HEADING1-297></A>
<HR>
<H2>2.1.10  The IsReg16 Macro</H2>
 Like it's eight-bit counterpart, this macro checks its operand to determine if we have a 16-bit register.  If the operand is the name of a 16-bit register, it returns that register as the function result, otherwise it returns an empty string as the function result.<P>
 <P>
<PRE>
;IsReg16-       Checks the parameter to see if it corresponds to a
;               valid 16-bit register.

IsReg16         macro   reg16
                ifidni  &lt;reg16&gt;, &lt;ax&gt;
                exitm   &lt;ax&gt;
                endif

                ifidni  &lt;reg16&gt;, &lt;bx&gt;
                exitm   &lt;bx&gt;
                endif

                ifidni  &lt;reg16&gt;, &lt;cx&gt;
                exitm   &lt;cx&gt;
                endif

                ifidni  &lt;reg16&gt;, &lt;dx&gt;
                exitm   &lt;dx&gt;
                endif

                ifidni  &lt;reg16&gt;, &lt;si&gt;
                exitm   &lt;si&gt;
                endif

                ifidni  &lt;reg16&gt;, &lt;di&gt;
                exitm   &lt;di&gt;
                endif

                ifidni  &lt;reg16&gt;, &lt;bp&gt;
                exitm   &lt;bp&gt;
                endif

                ifidni  &lt;reg16&gt;, &lt;sp&gt;
                exitm   &lt;sp&gt;
                endif

                exitm   &lt;&gt;      ;; Not a valid 16-bit register.
                endm

</PRE>
<A NAME=HEADING1-339></A>
<HR>
<H2>2.1.11  The IsReg32 Macro</H2>
 Like the IsReg8 and IsReg16 macros, the IsReg32 macro checks its operand to see if it is a 32-bit register.  This function returns the register name if it is a valid 32-bit register, it returns an empty string otherwise.  Typically you would call this macro in the operand field of an instruction that expects a 32-bit register or use this macro with the IFB directive.<P>
 <P>
<PRE>
;IsReg32-       Checks the parameter to see if it corresponds to a
;               valid 32-bit register.

IsReg32         macro   reg32
                ifidni  &lt;reg32&gt;, &lt;eax&gt;
                exitm   &lt;eax&gt;
                endif

                ifidni  &lt;reg32&gt;, &lt;ebx&gt;
                exitm   &lt;ebx&gt;
                endif

                ifidni  &lt;reg32&gt;, &lt;ecx&gt;
                exitm   &lt;ecx&gt;
                endif

                ifidni  &lt;reg32&gt;, &lt;edx&gt;
                exitm   &lt;edx&gt;
                endif

                ifidni  &lt;reg32&gt;, &lt;esi&gt;
                exitm   &lt;esi&gt;
                endif

                ifidni  &lt;reg32&gt;, &lt;edi&gt;
                exitm   &lt;edi&gt;
                endif

                ifidni  &lt;reg32&gt;, &lt;ebp&gt;
                exitm   &lt;ebp&gt;
                endif

                ifidni  &lt;reg32&gt;, &lt;esp&gt;
                exitm   &lt;esp&gt;
                endif

                exitm   &lt;&gt;      ;; Not a valid 32-bit register.
                endm

</PRE>
<A NAME=HEADING1-381></A>
<HR>
<H2>2.1.12  The $Push Macro</H2>
 Some of the control constructs in the Standard Library require a context free grammar (CFG) for proper implementation.  In particular, different macros need to communicate with one another.  A CFG requires the use of a stack.  The Standard Library uses text equates for stack variables.  An empty stack consists of an empty string.  Values pushed onto the stack are simply concatenated to the stack.  To separate items on the stack, the Standard Library uses the &quot;:&quot; character.  For example, after pushing the values 2, 3, and 6 onto a &quot;stack&quot;, the corresponding stack variable would contain the following text:<P>
 &lt; 6 : 3 : 2 : &gt;<P>
 <P>
 The $Push macro pushes a value onto a stack.  This macro requires two operands: the name of the stack on which to push the value (a MASM symbol) and a numeric value to push.  This function pushes the value by appending the current stack value to the text &lt; value : &gt;.<P>
 <P>
 This is a true macro, not a macro function.  Therefore, you would never call it from the operand field of some other instruction or diretive.<P>
 <P>
<PRE>
; $Push Symstk, Value
;
; Symstk is a symbol name (it need not already exist).
; Value is a numeric value.
; $Push &quot;pushes&quot; this value onto the stack named Symstk by
; concatenating the string equivalent of the value to the
; begining of the Symstk symbol as a text value.  Note that
; $push separates stack entries (which must be numbers) using
; the &quot;:&quot; symbol.

$push           macro   SymStk, value
                ifnb    &lt;value&gt;
SymStk          catstr  &lt;value&gt;, &lt;:&gt;, SymStk
                endif
                endm

</PRE>
<A NAME=HEADING1-405></A>
<HR>
<H2>2.1.13  The $Pop Macro</H2>
 The $Pop macro undoes the effect of the $Push macro.  It copies the prefix of a stack variable (all the characters up to the first &quot;:&quot; character) to its destination operand and then it removes the prefix characters (including the &quot;:&quot;) from the beginning of the stack variable.  Note that this  macro will report an error if you attempt to pop a value from an empty stack.  Like $Push, $Pop is a macro procedure, not a function.  Therefore it does not return a value (instead, it stores the popped value into the destination variable.<P>
 <P>
 <P>
<PRE>
; $Pop- extracts the top of stack value (a numeric value) and equates
; the dest symbol to this value.  $Pop removes the item on the top
; of the stack from the Symstk text value (everything up to and including
; the &quot;:&quot; stack separator).

$pop            macro   SymStk, dest
                local   posn

posn            instr   1,SymStk,&lt;:&gt;

                ifb     SymStk
                echo    Error- Empty stack (POP)
                err
                exitm
                endif

                if      posn ne 0
dest            substr  SymStk, 1, posn-1
                else
dest            textequ &lt;&gt;
                endif
                if      posn ne @sizestr(%&amp;SymStk&amp;)
SymStk          substr  SymStk, posn+1
                else
SymStk          textequ &lt;&gt;
                endif
                endm

</PRE>
<A NAME=HEADING1-437></A>
<HR>
<H2>2.1.14  The $Peek Macro</H2>
 The $Peek macro is similar to $Pop except it only returns the value currently on the top of the symbol stack;  it does not remove that item from the stack.<P>
 <P>
<PRE>
; $Peek is like $Pop except it does not remove the item from
; the top of the stack.

$peek           macro   SymStk, dest
                local   posn

posn            instr   1,SymStk,&lt;:&gt;

                ifb     SymStk
                echo    Error- Empty stack (PEEK)
                err
                exitm
                endif

                if      posn ne 0
dest            substr  SymStk, 1, posn-1
                else
dest            textequ &lt;&gt;
                endif
                endm

</PRE>
<A NAME=HEADING1-461></A>
<HR>
<H2>2.1.15  The Xtrn Macro</H2>
 The job of the xtrn macro is to write other macros.  Many of the Standard Library functions provide a wide variety of different calls that vary in the way one passes the parameters to the function.  For example, consider the IsAlpha function.  There are actually four different IsAlpha functions: $IsAlpha, $IsAlphaTOS, $IsAlphaStk, and $IsAlphaCS.  Each of these functions requires an externdef statement and a macro that lets you invoke the routine by simply specifying the names IsAlpha, IsAlphaTOS, IsAlphaStk, or IsAlphaCS (e.g., without having to specify the call instruction).  The xtrn macro provides a convenient way to create all these externdef and macro definitions.  To use xtrn, one simply specifies the base function name (e.g., IsAlpha) as the first operand and the allowable suffixes (e.g., TOS, STK, and CS) as the remaining operands.  The xtrn macro generates all the necessary macros and externdef statements from this operand list.  A typical call to xtrn would look like the following:<P>
 <P>
<PRE>
xtrn IsAlpha, TOS, STK, CS
</PRE>
 <P>
 Although the xtrn macro is intended primarily for the Standard Library routines, you can use it if you want to create your own library routines that use the same calling sequence and linkages as the Standard Library functions.<P>
 <P>
<PRE>
; xtrn- Generates a set of externdef statements for a given
;       label.  The first parameter specifies the name of the
;       symbol, the remaining parameters provide the suffixes.

xtrn            macro     name, suffixes:vararg
                externdef $&amp;name&amp;:far

                ifnb      &lt;suffixes&gt;
                for       suffix,&lt;suffixes&gt;
                externdef $&amp;name&amp;&amp;suffix&amp;:far
&amp;name&amp;&amp;suffix&amp;  textequ   &lt;call $&amp;name&amp;&amp;suffix&amp;&gt;
                endm
                else
&amp;name&amp;          textequ   &lt;call $&amp;name&amp;&gt;
                endif
                endm

</PRE>
<A NAME=HEADING1-485></A>
<HR>
<H2>2.1.16  The bCSStkTOS Macro</H2>
 The bCSStkTOS macro is one of several macros designed to implement other macros for Standard Library routines.  In particular, those Standard Library functions that operate on byte operands and support plain, CS, STK, and TOS modes typically use this macro to actually invoke a particular routine.<P>
 <P>
 The primary purpose of the bCSStkTOS macro is to call an appropriate Standard Library function and automatically handle the plain, register, constant, and pointer addressing modes.  For example, consider the IsAlpha Standard Library function.  The Standard Library supports the following variations of IsAlpha:<P>
 <P>
<PRE>
	IsAlpha
	IsAlphaTOS
	IsAlphaSTK
	IsAlphaCS

</PRE>
 A corresponding invocation of the xtrn macro generates the macros for these calls, you could call each of these functions using the following syntax:<P>
<PRE>

	mov al, CharToTest
	IsAlpha

	push word ptr CharToTest
	IsAlphaTOS

	pshadrs CharToTest
	IsAlphaStk

	IsAlphaCS
	dword CharToTest

</PRE>
 Note, however, that the Standard Library provides additional syntax allowing a more convenient use of the IsAlpha set of routines.  Specifically, you can supply an operand to IsAlpha as follows:<P>
<PRE>

	IsAlpha
	IsAlpha   bl             ;Or any 8-bit register
	IsAlpha   'a'            ;Or any 8-bit constant
	IsAlpha   CharVar
	IsAlpha   [wordvar]
	IsAlpha   [dwordvar]

</PRE>
 The first example above is the standard call to IsAlpha.  The second and third examples above actually push their operand onto the stack and call IsAlphaTOS.  The third example above (charvar) winds up calling the IsAlphaCS routine.  The last two examples above push the 32-bit address specified (DS assumed for word variables) onto the stack and call IsAlphaSTK.<P>
 <P>
 The bCSStkTOS macro handles processing the IsAlpha (and other routines') operand field to determine which routine it should actually call and how it should pass the parameters.  Basically, it uses the following algorithm:<P>
 <P>
<UL>
<LI>If the operand field is blank, emit a call to the standard function (passed as a parameter to bCSSTKTOS).<P>
<LI>If the operand field contains an eight-bit register or an eight-bit constant, push it onto the stack and call the xxxxTOS version of the routine.<P>
<LI>If the operand field contains an eight-bit variable, call the xxxxCS version of the routine and pass the address of the variable in the code stream.<P>
<LI>If the operand field contains [wordvar] then push DS, followed by the value of &quot;wordvar&quot; onto the stack and call xxxxSTK.<P>
<LI>If the operand field takes the form [dwordvar] then simply push the double word value onto the stack and call xxxxSTK.<P>
</UL>
 <P>
<PRE>

; bCSStkTOS:
;
;       Routines that have a byte operand and support the plain, CS,
;       Stk, and TOS addressing modes.


bCSStkTOS       macro   funcName, Operand

                ifb     &lt;Operand&gt;
                call    $&amp;funcName&amp;
                exitm
                endif

;; See if it's an eight-bit register

                ifnb    IsReg8( &lt;Operand&gt; )

                pReg8   &lt;Operand&gt;
                call    $&amp;funcName&amp;TOS
                exitm

                endif

;; See if it's a numeric constant

                if      IsNumConst( &lt;Operand&gt; )

                push    Operand
                call    $&amp;funcName&amp;TOS
                exitm

                endif

;; See if it's a byte variable:

                if      IsByte( &lt;Operand&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand
                exitm

                endif

;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr(&lt;Operand&gt;)
                push    ds
                push    IsWordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDwordPtr(&lt;Operand&gt;)
                pushd   IsDwordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
<A NAME=HEADING1-593></A>
<HR>
<H2>2.1.17  The bCSStk Macro</H2>
 Provides support like bCSStkTOS except this macro is intended for use by routines that do not supply the xxxxTOS call.  This macro is just a hacked-down version of bCSStk, so there is no real need to spend a lot of time discussing it.  Note that because of the TOS omission, this macro does not support the constant or register addressing modes.<P>
<PRE>

; bCSStk:
;
;       Input routines that have a byte operand and support the plain, CS,
;       and Stk addressing modes.


bCSStk          macro   funcName, Operand

                ifb     &lt;Operand&gt;
                call    $&amp;funcName&amp;
                exitm
                endif


;; See if it's a byte variable:

                if      IsByte( &lt;Operand&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand
                exitm

                endif

;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr(&lt;Operand&gt;)
                push    ds
                push    IsWordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDwordPtr(&lt;Operand&gt;)
                pushd   IsDwordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
<A NAME=HEADING1-641></A>
<HR>
<H2>2.1.18  The wCSStkTOS Macro</H2>
 The wCSStkTOS macro is one of several macros designed to implement other macros for Standard Library routines.  In particular, those Standard Library functions that operate on word operands and support plain, CS, STK, and TOS modes typically use this macro to actually invoke a particular routine.<P>
 <P>
 The primary purpose of the wCSStkTOS macro is to call an appropriate Standard Library function and automatically handle the plain, register, constant, and pointer addressing modes.  For example, consider the puti Standard Library function.  The Standard Library supports the following variations of puti:<P>
 <P>
<PRE>
	puti
	putiTOS
	putiSTK
	putiCS

</PRE>
 A corresponding invocation of the xtrn macro generates the macros for these calls, you could call each of these functions using the following syntax:<P>
<PRE>

	mov ax, IntToPrint
	puti

	push IntToPrint
	putiTOS

	pshadrs IntToPrint
	putiStk

	puti
	dword IntToPrint

</PRE>
 Note, however, that the Standard Library provides additional syntax allowing a more convenient use of the puti set of routines.  Specifically, you can supply an operand to puti as follows:<P>
<PRE>

	puti
	puti      bx             ;Or any 16-bit register
	puti      125            ;Or any 16-bit constant
	puti      IntToPrint
	puti      [wordvar]
	puti      [dwordvar]

</PRE>
 The first example above is the standard call to puti.  The second and third examples above actually push their operand onto the stack and call putiTOS.  The third example above (IntToPrint) winds up calling the putiCS routine.  The last two examples above push the 32-bit address specified (DS assumed for word variables) onto the stack and call putiSTK.<P>
 <P>
 The wCSStkTOS macro handles processing the puti (and other routines') operand field to determine which routine it should actually call and how it should pass the parameters.  Basically, it uses the following algorithm:<P>
 <P>
<UL>
<LI>If the operand field is blank, emit a call to the standard function (passed as a parameter to wCSSTKTOS).<P>
<LI>If the operand field contains a 16-bit register or a 16-bit constant, push it onto the stack and call the xxxxTOS version of the routine.<P>
<LI>If the operand field contains an 16-bit variable, call the xxxxCS version of the routine and pass the address of the variable in the code stream.<P>
<LI>If the operand field contains [wordvar] then push DS, followed by the value of &quot;wordvar&quot; onto the stack and call xxxxSTK.<P>
<LI>If the operand field takes the form [dwordvar] then simply push the double word value onto the stack and call xxxxSTK.<P>
</UL>
 <P>
 <P>
<PRE>

; wCSStkTOS:
;
;       Routines that have a word operand and support the plain, CS,
;       Stk, and TOS addressing modes.


wCSStkTOS       macro   funcName, Operand

                ifb     &lt;Operand&gt;
                call    $&amp;funcName&amp;
                exitm
                endif

;; See if it's a 16-bit register

                ifnb    IsReg16( &lt;Operand&gt; )

                push    IsReg16( &lt;Operand&gt; )
                call    $&amp;funcName&amp;TOS
                exitm

                endif

;; See if it's a numeric constant

                if      IsNumConst( &lt;Operand&gt; )

                push    Operand
                call    $&amp;funcName&amp;TOS
                exitm

                endif

;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr(&lt;Operand&gt;)
                push    ds
                push    IsWordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDwordPtr(&lt;Operand&gt;)
                pushd   IsDwordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

;; See if it's a word variable:

                if      IsWord( &lt;Operand&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand
                exitm

                endif

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
<A NAME=HEADING1-750></A>
<HR>
<H2>2.1.19  The wCSStk Macro</H2>
 Provides support like wCSStkTOS except this macro is intended for use by routines that do not supply the xxxxTOS call.  This macro is just a hacked-down version of wCSStk, so there is no real need to spend a lot of time discussing it.  Note that because of the TOS omission, this macro does not support the constant or register addressing modes.<P>
<PRE>


; wCSStk:
;
;       Input routines that have a word operand and support the plain, CS,
;       and Stk addressing modes, returning a 16-bit value.


wCSStk          macro   funcName, Operand

                ifb     &lt;Operand&gt;
                call    $&amp;funcName&amp;
                exitm
                endif

;; See if it's a 16-bit register (need to implement TOS mode
;; for getc, etc.)
;;
;;              ifnb    IsReg16( &lt;Operand&gt; )
;;
;;              call    $&amp;funcName&amp;TOS
;;              pop     IsReg16( &lt;Operand&gt; )
;;              exitm
;;
;;              endif


;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr(&lt;Operand&gt;)
                push    ds
                push    IsWordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDwordPtr(&lt;Operand&gt;)
                pushd   IsDwordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

;; See if it's a word variable:

                if      IsWord( &lt;Operand&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand
                exitm

                endif

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm





; LCSStkTOS:
;
;       Routines that have a dword operand and support the plain, CS,
;       Stk, and TOS addressing modes.

</PRE>
<A NAME=HEADING1-819></A>
<HR>
<H2>2.1.20  The LCSStkTOS Macro</H2>
 The LCSStkTOS macro is one of several macros designed to implement other macros for Standard Library routines.  In particular, those Standard Library functions that operate on dword (long)  operands and support plain, CS, STK, and TOS modes typically use this macro to actually invoke a particular routine.<P>
 <P>
 The primary purpose of the LCSStkTOS macro is to call an appropriate Standard Library function and automatically handle the plain, register, constant, and pointer addressing modes.  For example, consider the putl Standard Library function.  The Standard Library supports the following variations of putl:<P>
 <P>
<PRE>
	putl
	putlTOS
	putlSTK
	putlCS

</PRE>
 A corresponding invocation of the xtrn macro generates the macros for these calls, you could call each of these functions using the following syntax:<P>
<PRE>

	mov ax, LongToPrint
	putl

	push LongToPrint
	putlTOS

	pshadrs LongToPrint
	putlStk

	putl
	dword LongToPrint

</PRE>
 Note, however, that the Standard Library provides additional syntax allowing a more convenient use of the putl set of routines.  Specifically, you can supply an operand to putl as follows:<P>
<PRE>

	putl
	putl      ebx            ;Or any 32-bit register
	putl      125            ;Or any 32-bit constant
	putl      LongToPrint
	putl      [wordvar]
	putl      [dwordvar]

</PRE>
 The first example above is the standard call to putl.  The second and third examples above actually push their operand onto the stack and call putlTOS.  The third example above (LongToPrint) winds up calling the putlCS routine.  The last two examples above push the 32-bit address specified (DS assumed for word variables) onto the stack and call putlSTK.<P>
 <P>
 The LCSStkTOS macro handles processing the putl (and other routines') operand field to determine which routine it should actually call and how it should pass the parameters.  Basically, it uses the following algorithm:<P>
 <P>
<UL>
<LI>If the operand field is blank, emit a call to the standard function (passed as a parameter to LCSSTKTOS).<P>
<LI>If the operand field contains a 32-bit register or a 32-bit constant, push it onto the stack and call the xxxxTOS version of the routine.<P>
<LI>If the operand field contains an 32-bit variable, call the xxxxCS version of the routine and pass the address of the variable in the code stream.<P>
<LI>If the operand field contains [wordvar] then push DS, followed by the value of &quot;wordvar&quot; onto the stack and call xxxxSTK.<P>
<LI>If the operand field takes the form [dwordvar] then simply push the double word value onto the stack and call xxxxSTK.<P>
</UL>
 <P>
<PRE>

LCSStkTOS       macro   funcName, Operand

                ifb     &lt;Operand&gt;
                call    $&amp;funcName&amp;
                exitm
                endif

;; See if it's a 16-bit register

                ifnb    IsReg32( &lt;Operand&gt; )

                push    IsReg32( &lt;Operand&gt; )
                call    $&amp;funcName&amp;TOS
                exitm

                endif

;; See if it's a numeric constant

                if      IsNumConst( &lt;Operand&gt; )

                pushd   Operand
                call    $&amp;funcName&amp;TOS
                exitm

                endif

;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr(&lt;Operand&gt;)
                push    ds
                push    IsWordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDwordPtr(&lt;Operand&gt;)
                pushd   IsDwordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

;; See if it's a dword variable:

                if      IsDWord( &lt;Operand&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand
                exitm

                endif

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
<A NAME=HEADING1-921></A>
<HR>
<H2>2.1.21  The LCSSTK Macro</H2>
 Provides support like LCSStkTOS except this macro is intended for use by routines that do not supply the xxxxTOS call.  This macro is just a hacked-down version of LCSStk, so there is no real need to spend a lot of time discussing it.  Note that because of the TOS omission, this macro does not support the constant or register addressing modes.<P>
 <P>
 <P>
<PRE>
; lCSStk:
;
;       Input routines that have a word operand and support the plain, CS,
;       and Stk addressing modes, returning a 32-bit value.


lCSStk          macro   funcName, Operand

                ifb     &lt;Operand&gt;
                call    $&amp;funcName&amp;
                exitm
                endif

;; See if it's a 32-bit register (need to implement TOS mode
;; for getul, etc.)
;;
;;              ifnb    IsReg32( &lt;Operand&gt; )
;;
;;              call    $&amp;funcName&amp;TOS
;;              pop     IsReg32( &lt;Operand&gt; )
;;              exitm
;;
;;              endif


;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr(&lt;Operand&gt;)
                push    ds
                push    IsWordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDwordPtr(&lt;Operand&gt;)
                pushd   IsDwordPtr(&lt;Operand&gt;)
                call    $&amp;funcName&amp;Stk
                exitm
                endif

;; See if it's a dword variable:

                if      IsDWord( &lt;Operand&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand
                exitm

                endif

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
<A NAME=HEADING1-981></A>
<HR>
<H2>2.1.22  The sbCSStkTOS Macro</H2>
 The sbCSStkTOS macro is one of several macros designed to implement other macros for Standard Library routines.  Standard Library functions that operate on a byte operand producing a string result, or operate on a string operand producing a byte result typically use this macro.  This macro supports the plain, CS, STK, and TOS modes for use with the byte operand.<P>
 <P>
 The primary purpose of the sbCSStkTOS macro is to call an appropriate Standard Library function and automatically handle the plain, register, constant, and pointer addressing modes.  For example, consider the htoa Standard Library function.  The Standard Library supports the following variations of htoa:<P>
 <P>
<PRE>
	htoa
	htoaTOS
	htoaSTK
	htoaCS

</PRE>
 A corresponding invocation of the xtrn macro generates the macros for these calls, you could call each of these functions using the following syntax:<P>
<PRE>

	lesi    StringVar
	htoa                ;Leaves value in AL.

	pshadrs StringVar
	htoaTOS             ;Leaves value on TOS.

	pshadrs StringVar   ;Address of eight-bit value
	pshadrs HexValue
	htoaStk

	htoaCS              ;Leaves value in AL.
	dword StringVar

</PRE>
 Note, however, that the Standard Library provides additional syntax allowing a more convenient use of the atoh set of routines.  Specifically, you can supply an operand to htoa as follows:<P>
<PRE>

	htoa
	htoa      HexValue, StringVar     ;Uses TOS form
	htoa      HexVar, StringVar       ;Uses Stk form.

</PRE>
 The first example above is the standard call to htoa.  The second example above actually pushes the value of hexValue and the address of StringVar onto the stack and calls htoaTOS.  The third example above winds up calling the htoaStk routine.<P>
 <P>
 The sbSStkTOS macro handles processing the htoa (and other routines') operand field to determine which routine it should actually call and how it should pass the parameters.  Basically, it uses the following algorithm:<P>
 <P>
<UL>
<LI>If the operand field is blank, emit a call to the standard function (passed as a parameter to sbCSSTKTOS).<P>
<LI>If the first operand field is a constant or register and the second operand is a string varible, sbCSStkTOS calls the xxxTOS routine.<P>
<LI>If the operand field contains an 8-bit variable and a string variable, the sbCSStkTOS macro calls the xxxxStk version of the routine and pushes the addresses of the variables onto the stack.<P>
<LI>If either operand field contains [wordvar] then push DS, followed by the value of &quot;wordvar&quot; onto the stack and call xxxxSTK.<P>
<LI>If either operand field takes the form [dwordvar] then simply push the double word value onto the stack and call xxxxSTK.<P>
</UL>
 <P>
<PRE>

; sbCSStkTOS:
;
;       Routines that have a string operand and support the plain, CS,
;       Stk, and TOS addressing modes.
;
;       They must produce a 8-bit result and leave the result in
;       AL, TOS, or a destination byte.
;
;       Note:   The &quot;ScndOpb&quot; macro handles the second operand if it
;               is present.

ScndOpb         macro   Operand2, funcName
                if      IsByte( &lt;Operand2&gt; )
                push    seg &amp;Operand2&amp;
                push    offset &amp;Operand2&amp;
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsWordPtr( &lt;Operand2&gt; )
                push    ds
                push    IsWordPtr( &lt;Operand2&gt; )
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDWordPtr( &lt;Operand2&gt; )
                push    IsDWordPtr( &lt;Operand2&gt; )
                call    $&amp;funcName&amp;Stk
                exitm
                endif

%               echo    If &amp;funcName has two operands,  then second
                echo    operand must be a byte, [word], or [dword] parameter.
                err

                endm



sbCSStkTOS      macro   funcName, Operand1, Operand2

                ifb     &lt;Operand2&gt;

                ifb     &lt;Operand1&gt;
                call    $&amp;funcName&amp;
                exitm
                endif


;; See if it's a byte variable:

                if      IsByte( &lt;Operand1&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand1
                exitm

                endif




                else    ;Operand2 is not blank




                if      IsByte( &lt;Operand1&gt; )

                push    seg &amp;Operand1&amp;
                push    offset &amp;Operand1&amp;

                ScndOpb Operand2, funcName
                exitm

                endif   ;IsByte




;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr( &lt;Operand1&gt; )
                push    ds
                push    IsWordPtr( &lt;Operand1&gt; )

                ScndOpb Operand2, funcName
                exitm

                endif


; Check far ptr here.

                ifnb    IsDwordPtr(&lt;Operand1&gt;)
                pushd   IsDwordPtr(&lt;Operand1&gt;)
                
                ScndOpb Operand2, funcName
                exitm
                endif


                endif   ;Check of operand2.

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
<A NAME=HEADING1-1134></A>
<HR>
<H2>2.1.23  The swCSStkTOS Macro</H2>
 The swCSStkTOS macro is virtually identical to the sbCSStkTOS macro except it handles a word and string operand pair rather than a byte and string operand pair.  Standard Library routines like AtoI and ItoA use this macro.<P>
 <P>
<PRE>

swCSStkTOS      macro   funcName, Operand1, Operand2

                ifb     &lt;Operand2&gt;

                ifb     &lt;Operand1&gt;
                call    $&amp;funcName&amp;
                exitm
                endif


;; See if it's a byte variable:

                if      IsByte( &lt;Operand1&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand1
                exitm

                endif




                else    ;Operand2 is not blank




                if      IsByte( &lt;Operand1&gt; )

                push    seg &amp;Operand1&amp;
                push    offset &amp;Operand1&amp;

                ScndOpw Operand2, funcName
                exitm

                endif   ;IsByte




;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr( &lt;Operand1&gt; )
                push    ds
                push    IsWordPtr( &lt;Operand1&gt; )

                ScndOpw Operand2, funcName
                exitm

                endif


; Check far ptr here.

                ifnb    IsDwordPtr(&lt;Operand1&gt;)
                pushd   IsDwordPtr(&lt;Operand1&gt;)
                
                ScndOpw Operand2, funcName
                exitm
                endif


                endif   ;Check of operand2.

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
<A NAME=HEADING1-1209></A>
<HR>
<H2>2.1.24  The sdCSStkTOS Macro</H2>
 The sdCSStkTOS macro is virtually identical to the sbCSStkTOS macro except it handles a dword and string operand pair rather than a byte and string operand pair.  Standard Library routines like AtoL and LtoA use this macro.<P>
 <P>
 <P>
<PRE>

; sdCSStkTOS:
;
;       Routines that have a string operand and support the plain, CS,
;       Stk, and TOS addressing modes.
;
;       They must produce a 32-bit result and leave the result in
;       EAX, TOS, or a destination word.
;
;       Note:   The &quot;ScndOpd&quot; macro handles the second operand if it
;               is present.

ScndOpd         macro   Operand2, funcName
                if      IsDWord( &lt;Operand2&gt; )
                push    seg &amp;Operand2&amp;
                push    offset &amp;Operand2&amp;
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsWordPtr( &lt;Operand2&gt; )
                push    ds
                push    IsWordPtr( &lt;Operand2&gt; )
                call    $&amp;funcName&amp;Stk
                exitm
                endif

                ifnb    IsDWordPtr( &lt;Operand2&gt; )
                push    IsDWordPtr( &lt;Operand2&gt; )
                call    $&amp;funcName&amp;Stk
                exitm
                endif

%               echo    If &amp;funcName has two operands,  then second
                echo    operand must be a dword, [word], or [dword] parameter.
                err

                endm



sdCSStkTOS      macro   funcName, Operand1, Operand2

                ifb     &lt;Operand2&gt;

                ifb     &lt;Operand1&gt;
                call    $&amp;funcName&amp;
                exitm
                endif


;; See if it's a byte variable:

                if      IsByte( &lt;Operand1&gt; )

                call    $&amp;funcName&amp;CS
                dword   Operand1
                exitm

                endif




                else    ;Operand2 is not blank




                if      IsByte( &lt;Operand1&gt; )

                push    seg &amp;Operand1&amp;
                push    offset &amp;Operand1&amp;

                ScndOpd Operand2, funcName
                exitm

                endif   ;IsByte




;; See if it's a near or far pointer variable.

                ifnb    IsWordPtr( &lt;Operand1&gt; )
                push    ds
                push    IsWordPtr( &lt;Operand1&gt; )

                ScndOpd Operand2, funcName
                exitm

                endif


; Check far ptr here.

                ifnb    IsDwordPtr(&lt;Operand1&gt;)
                pushd   IsDwordPtr(&lt;Operand1&gt;)
                
                ScndOpd Operand2, funcName
                exitm
                endif


                endif   ;Check of operand2.

;; If it's not any of the above, we have an error.

%               echo    Illegal &amp;funcName&amp; operand.
                err
                endm

</PRE>
</BODY>
</HTML> 